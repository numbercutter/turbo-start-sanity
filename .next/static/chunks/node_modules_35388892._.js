(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_35388892._.js", {

"[project]/node_modules/react-compiler-runtime/dist/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @lightSyntaxTransform
 * @noflow
 * @nolint
 * @preventMunge
 * @preserve-invariant-messages
 */ "use no memo";
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var index_exports = {};
__export(index_exports, {
    $dispatcherGuard: ()=>$dispatcherGuard,
    $makeReadOnly: ()=>$makeReadOnly,
    $reset: ()=>$reset,
    $structuralCheck: ()=>$structuralCheck,
    c: ()=>c,
    clearRenderCounterRegistry: ()=>clearRenderCounterRegistry,
    renderCounterRegistry: ()=>renderCounterRegistry,
    useRenderCounter: ()=>useRenderCounter
});
module.exports = __toCommonJS(index_exports);
var React = __toESM(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-experimental/index.js [app-client] (ecmascript)"));
var { useRef, useEffect, isValidElement } = React;
var _a;
var ReactSecretInternals = //@ts-ignore
(_a = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE) != null ? _a : React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
var $empty = Symbol.for("react.memo_cache_sentinel");
var _a2;
var c = // @ts-expect-error
typeof ((_a2 = React.__COMPILER_RUNTIME) == null ? void 0 : _a2.c) === "function" ? // @ts-expect-error
React.__COMPILER_RUNTIME.c : function c2(size) {
    return React.useMemo({
        "c2.useMemo": ()=>{
            const $ = new Array(size);
            for(let ii = 0; ii < size; ii++){
                $[ii] = $empty;
            }
            $[$empty] = true;
            return $;
        }
    }["c2.useMemo"], []);
};
var LazyGuardDispatcher = {};
[
    "readContext",
    "useCallback",
    "useContext",
    "useEffect",
    "useImperativeHandle",
    "useInsertionEffect",
    "useLayoutEffect",
    "useMemo",
    "useReducer",
    "useRef",
    "useState",
    "useDebugValue",
    "useDeferredValue",
    "useTransition",
    "useMutableSource",
    "useSyncExternalStore",
    "useId",
    "unstable_isNewReconciler",
    "getCacheSignal",
    "getCacheForType",
    "useCacheRefresh"
].forEach((name)=>{
    LazyGuardDispatcher[name] = ()=>{
        throw new Error(`[React] Unexpected React hook call (${name}) from a React compiled function. Check that all hooks are called directly and named according to convention ('use[A-Z]') `);
    };
});
var originalDispatcher = null;
LazyGuardDispatcher["useMemoCache"] = (count)=>{
    if (originalDispatcher == null) {
        throw new Error("React Compiler internal invariant violation: unexpected null dispatcher");
    } else {
        return originalDispatcher.useMemoCache(count);
    }
};
function setCurrent(newDispatcher) {
    ReactSecretInternals.ReactCurrentDispatcher.current = newDispatcher;
    return ReactSecretInternals.ReactCurrentDispatcher.current;
}
var guardFrames = [];
function $dispatcherGuard(kind) {
    const curr = ReactSecretInternals.ReactCurrentDispatcher.current;
    if (kind === 0 /* PushGuardContext */ ) {
        guardFrames.push(curr);
        if (guardFrames.length === 1) {
            originalDispatcher = curr;
        }
        if (curr === LazyGuardDispatcher) {
            throw new Error(`[React] Unexpected call to custom hook or component from a React compiled function. Check that (1) all hooks are called directly and named according to convention ('use[A-Z]') and (2) components are returned as JSX instead of being directly invoked.`);
        }
        setCurrent(LazyGuardDispatcher);
    } else if (kind === 1 /* PopGuardContext */ ) {
        const lastFrame = guardFrames.pop();
        if (lastFrame == null) {
            throw new Error("React Compiler internal error: unexpected null in guard stack");
        }
        if (guardFrames.length === 0) {
            originalDispatcher = null;
        }
        setCurrent(lastFrame);
    } else if (kind === 2 /* PushExpectHook */ ) {
        guardFrames.push(curr);
        setCurrent(originalDispatcher);
    } else if (kind === 3 /* PopExpectHook */ ) {
        const lastFrame = guardFrames.pop();
        if (lastFrame == null) {
            throw new Error("React Compiler internal error: unexpected null in guard stack");
        }
        setCurrent(lastFrame);
    } else {
        throw new Error("React Compiler internal error: unreachable block" + kind);
    }
}
function $reset($) {
    for(let ii = 0; ii < $.length; ii++){
        $[ii] = $empty;
    }
}
function $makeReadOnly() {
    throw new Error("TODO: implement $makeReadOnly in react-compiler-runtime");
}
var renderCounterRegistry = /* @__PURE__ */ new Map();
function clearRenderCounterRegistry() {
    for (const counters of renderCounterRegistry.values()){
        counters.forEach((counter)=>{
            counter.count = 0;
        });
    }
}
function registerRenderCounter(name, val) {
    let counters = renderCounterRegistry.get(name);
    if (counters == null) {
        counters = /* @__PURE__ */ new Set();
        renderCounterRegistry.set(name, counters);
    }
    counters.add(val);
}
function removeRenderCounter(name, val) {
    const counters = renderCounterRegistry.get(name);
    if (counters == null) {
        return;
    }
    counters.delete(val);
}
function useRenderCounter(name) {
    const val = useRef(null);
    if (val.current != null) {
        val.current.count += 1;
    }
    useEffect({
        "useRenderCounter.useEffect": ()=>{
            if (val.current == null) {
                const counter = {
                    count: 0
                };
                registerRenderCounter(name, counter);
                val.current = counter;
            }
            return ({
                "useRenderCounter.useEffect": ()=>{
                    if (val.current !== null) {
                        removeRenderCounter(name, val.current);
                    }
                }
            })["useRenderCounter.useEffect"];
        }
    }["useRenderCounter.useEffect"]);
}
var seenErrors = /* @__PURE__ */ new Set();
function $structuralCheck(oldValue, newValue, variableName, fnName, kind, loc) {
    function error(l, r, path, depth) {
        const str = `${fnName}:${loc} [${kind}] ${variableName}${path} changed from ${l} to ${r} at depth ${depth}`;
        if (seenErrors.has(str)) {
            return;
        }
        seenErrors.add(str);
        console.error(str);
    }
    const depthLimit = 2;
    function recur(oldValue2, newValue2, path, depth) {
        if (depth > depthLimit) {
            return;
        } else if (oldValue2 === newValue2) {
            return;
        } else if (typeof oldValue2 !== typeof newValue2) {
            error(`type ${typeof oldValue2}`, `type ${typeof newValue2}`, path, depth);
        } else if (typeof oldValue2 === "object") {
            const oldArray = Array.isArray(oldValue2);
            const newArray = Array.isArray(newValue2);
            if (oldValue2 === null && newValue2 !== null) {
                error("null", `type ${typeof newValue2}`, path, depth);
            } else if (newValue2 === null) {
                error(`type ${typeof oldValue2}`, "null", path, depth);
            } else if (oldValue2 instanceof Map) {
                if (!(newValue2 instanceof Map)) {
                    error(`Map instance`, `other value`, path, depth);
                } else if (oldValue2.size !== newValue2.size) {
                    error(`Map instance with size ${oldValue2.size}`, `Map instance with size ${newValue2.size}`, path, depth);
                } else {
                    for (const [k, v] of oldValue2){
                        if (!newValue2.has(k)) {
                            error(`Map instance with key ${k}`, `Map instance without key ${k}`, path, depth);
                        } else {
                            recur(v, newValue2.get(k), `${path}.get(${k})`, depth + 1);
                        }
                    }
                }
            } else if (newValue2 instanceof Map) {
                error("other value", `Map instance`, path, depth);
            } else if (oldValue2 instanceof Set) {
                if (!(newValue2 instanceof Set)) {
                    error(`Set instance`, `other value`, path, depth);
                } else if (oldValue2.size !== newValue2.size) {
                    error(`Set instance with size ${oldValue2.size}`, `Set instance with size ${newValue2.size}`, path, depth);
                } else {
                    for (const v of newValue2){
                        if (!oldValue2.has(v)) {
                            error(`Set instance without element ${v}`, `Set instance with element ${v}`, path, depth);
                        }
                    }
                }
            } else if (newValue2 instanceof Set) {
                error("other value", `Set instance`, path, depth);
            } else if (oldArray || newArray) {
                if (oldArray !== newArray) {
                    error(`type ${oldArray ? "array" : "object"}`, `type ${newArray ? "array" : "object"}`, path, depth);
                } else if (oldValue2.length !== newValue2.length) {
                    error(`array with length ${oldValue2.length}`, `array with length ${newValue2.length}`, path, depth);
                } else {
                    for(let ii = 0; ii < oldValue2.length; ii++){
                        recur(oldValue2[ii], newValue2[ii], `${path}[${ii}]`, depth + 1);
                    }
                }
            } else if (isValidElement(oldValue2) || isValidElement(newValue2)) {
                if (isValidElement(oldValue2) !== isValidElement(newValue2)) {
                    error(`type ${isValidElement(oldValue2) ? "React element" : "object"}`, `type ${isValidElement(newValue2) ? "React element" : "object"}`, path, depth);
                } else if (oldValue2.type !== newValue2.type) {
                    error(`React element of type ${oldValue2.type}`, `React element of type ${newValue2.type}`, path, depth);
                } else {
                    recur(oldValue2.props, newValue2.props, `[props of ${path}]`, depth + 1);
                }
            } else {
                for(const key in newValue2){
                    if (!(key in oldValue2)) {
                        error(`object without key ${key}`, `object with key ${key}`, path, depth);
                    }
                }
                for(const key in oldValue2){
                    if (!(key in newValue2)) {
                        error(`object with key ${key}`, `object without key ${key}`, path, depth);
                    } else {
                        recur(oldValue2[key], newValue2[key], `${path}.${key}`, depth + 1);
                    }
                }
            }
        } else if (typeof oldValue2 === "function") {
            return;
        } else if (isNaN(oldValue2) || isNaN(newValue2)) {
            if (isNaN(oldValue2) !== isNaN(newValue2)) {
                error(`${isNaN(oldValue2) ? "NaN" : "non-NaN value"}`, `${isNaN(newValue2) ? "NaN" : "non-NaN value"}`, path, depth);
            }
        } else if (oldValue2 !== newValue2) {
            error(oldValue2, newValue2, path, depth);
        }
    }
    recur(oldValue, newValue, "", 0);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    $dispatcherGuard,
    $makeReadOnly,
    $reset,
    $structuralCheck,
    c,
    clearRenderCounterRegistry,
    renderCounterRegistry,
    useRenderCounter
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@sanity/client/dist/_chunks-es/resolveEditInfo.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DRAFTS_FOLDER": (()=>DRAFTS_FOLDER),
    "VERSION_FOLDER": (()=>VERSION_FOLDER),
    "createEditUrl": (()=>createEditUrl),
    "get": (()=>get),
    "getDraftId": (()=>getDraftId),
    "getPublishedId": (()=>getPublishedId),
    "getVersionFromId": (()=>getVersionFromId),
    "getVersionId": (()=>getVersionId),
    "isDraftId": (()=>isDraftId),
    "isPublishedId": (()=>isPublishedId),
    "isVersionId": (()=>isVersionId),
    "jsonPath": (()=>jsonPath),
    "jsonPathToStudioPath": (()=>jsonPathToStudioPath),
    "parseJsonPath": (()=>parseJsonPath),
    "reKeySegment": (()=>reKeySegment),
    "resolveEditInfo": (()=>resolveEditInfo),
    "resolveMapping": (()=>resolveMapping),
    "resolveStudioBaseRoute": (()=>resolveStudioBaseRoute),
    "studioPath": (()=>studioPath),
    "studioPathToJsonPath": (()=>studioPathToJsonPath),
    "toString": (()=>toString),
    "walkMap": (()=>walkMap)
});
const rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reKeySegment = /_key\s*==\s*['"](.*)['"]/, reIndexTuple = /^\d*:\d*$/;
function isIndexSegment(segment) {
    return typeof segment == "number" || typeof segment == "string" && /^\[\d+\]$/.test(segment);
}
function isKeySegment(segment) {
    return typeof segment == "string" ? reKeySegment.test(segment.trim()) : typeof segment == "object" && "_key" in segment;
}
function isIndexTuple(segment) {
    if (typeof segment == "string" && reIndexTuple.test(segment)) return !0;
    if (!Array.isArray(segment) || segment.length !== 2) return !1;
    const [from, to] = segment;
    return (typeof from == "number" || from === "") && (typeof to == "number" || to === "");
}
function get(obj, path, defaultVal) {
    const select = typeof path == "string" ? fromString(path) : path;
    if (!Array.isArray(select)) throw new Error("Path must be an array or a string");
    let acc = obj;
    for(let i = 0; i < select.length; i++){
        const segment = select[i];
        if (isIndexSegment(segment)) {
            if (!Array.isArray(acc)) return defaultVal;
            acc = acc[segment];
        }
        if (isKeySegment(segment)) {
            if (!Array.isArray(acc)) return defaultVal;
            acc = acc.find((item)=>item._key === segment._key);
        }
        if (typeof segment == "string" && (acc = typeof acc == "object" && acc !== null ? acc[segment] : void 0), typeof acc > "u") return defaultVal;
    }
    return acc;
}
function toString(path) {
    if (!Array.isArray(path)) throw new Error("Path is not an array");
    return path.reduce((target, segment, i)=>{
        const segmentType = typeof segment;
        if (segmentType === "number") return `${target}[${segment}]`;
        if (segmentType === "string") return `${target}${i === 0 ? "" : "."}${segment}`;
        if (isKeySegment(segment) && segment._key) return `${target}[_key=="${segment._key}"]`;
        if (Array.isArray(segment)) {
            const [from, to] = segment;
            return `${target}[${from}:${to}]`;
        }
        throw new Error(`Unsupported path segment \`${JSON.stringify(segment)}\``);
    }, "");
}
function fromString(path) {
    if (typeof path != "string") throw new Error("Path is not a string");
    const segments = path.match(rePropName);
    if (!segments) throw new Error("Invalid path string");
    return segments.map(parsePathSegment);
}
function parsePathSegment(segment) {
    return isIndexSegment(segment) ? parseIndexSegment(segment) : isKeySegment(segment) ? parseKeySegment(segment) : isIndexTuple(segment) ? parseIndexTupleSegment(segment) : segment;
}
function parseIndexSegment(segment) {
    return Number(segment.replace(/[^\d]/g, ""));
}
function parseKeySegment(segment) {
    return {
        _key: segment.match(reKeySegment)[1]
    };
}
function parseIndexTupleSegment(segment) {
    const [from, to] = segment.split(":").map((seg)=>seg === "" ? seg : Number(seg));
    return [
        from,
        to
    ];
}
var studioPath = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    fromString,
    get,
    isIndexSegment,
    isIndexTuple,
    isKeySegment,
    reKeySegment,
    toString
});
const DRAFTS_FOLDER = "drafts", VERSION_FOLDER = "versions", PATH_SEPARATOR = ".", DRAFTS_PREFIX = `${DRAFTS_FOLDER}${PATH_SEPARATOR}`, VERSION_PREFIX = `${VERSION_FOLDER}${PATH_SEPARATOR}`;
function isDraftId(id) {
    return id.startsWith(DRAFTS_PREFIX);
}
function isVersionId(id) {
    return id.startsWith(VERSION_PREFIX);
}
function isPublishedId(id) {
    return !isDraftId(id) && !isVersionId(id);
}
function getDraftId(id) {
    if (isVersionId(id)) {
        const publishedId = getPublishedId(id);
        return DRAFTS_PREFIX + publishedId;
    }
    return isDraftId(id) ? id : DRAFTS_PREFIX + id;
}
function getVersionId(id, version) {
    if (version === "drafts" || version === "published") throw new Error('Version can not be "published" or "drafts"');
    return `${VERSION_PREFIX}${version}${PATH_SEPARATOR}${getPublishedId(id)}`;
}
function getVersionFromId(id) {
    if (!isVersionId(id)) return;
    const [_versionPrefix, versionId, ..._publishedId] = id.split(PATH_SEPARATOR);
    return versionId;
}
function getPublishedId(id) {
    return isVersionId(id) ? id.split(PATH_SEPARATOR).slice(2).join(PATH_SEPARATOR) : isDraftId(id) ? id.slice(DRAFTS_PREFIX.length) : id;
}
const ESCAPE = {
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "'": "\\'",
    "\\": "\\\\"
}, UNESCAPE = {
    "\\f": "\f",
    "\\n": `
`,
    "\\r": "\r",
    "\\t": "	",
    "\\'": "'",
    "\\\\": "\\"
};
function jsonPath(path) {
    return `$${path.map((segment)=>typeof segment == "string" ? `['${segment.replace(/[\f\n\r\t'\\]/g, (match)=>ESCAPE[match])}']` : typeof segment == "number" ? `[${segment}]` : segment._key !== "" ? `[?(@._key=='${segment._key.replace(/['\\]/g, (match)=>ESCAPE[match])}')]` : `[${segment._index}]`).join("")}`;
}
function parseJsonPath(path) {
    const parsed = [], parseRe = /\['(.*?)'\]|\[(\d+)\]|\[\?\(@\._key=='(.*?)'\)\]/g;
    let match;
    for(; (match = parseRe.exec(path)) !== null;){
        if (match[1] !== void 0) {
            const key = match[1].replace(/\\(\\|f|n|r|t|')/g, (m)=>UNESCAPE[m]);
            parsed.push(key);
            continue;
        }
        if (match[2] !== void 0) {
            parsed.push(parseInt(match[2], 10));
            continue;
        }
        if (match[3] !== void 0) {
            const _key = match[3].replace(/\\(\\')/g, (m)=>UNESCAPE[m]);
            parsed.push({
                _key,
                _index: -1
            });
            continue;
        }
    }
    return parsed;
}
function jsonPathToStudioPath(path) {
    return path.map((segment)=>{
        if (typeof segment == "string" || typeof segment == "number") return segment;
        if (segment._key !== "") return {
            _key: segment._key
        };
        if (segment._index !== -1) return segment._index;
        throw new Error(`invalid segment:${JSON.stringify(segment)}`);
    });
}
function studioPathToJsonPath(path) {
    return (typeof path == "string" ? fromString(path) : path).map((segment)=>{
        if (typeof segment == "string" || typeof segment == "number") return segment;
        if (Array.isArray(segment)) throw new Error(`IndexTuple segments aren't supported:${JSON.stringify(segment)}`);
        if (isContentSourceMapParsedPathKeyedSegment(segment)) return segment;
        if (segment._key) return {
            _key: segment._key,
            _index: -1
        };
        throw new Error(`invalid segment:${JSON.stringify(segment)}`);
    });
}
function isContentSourceMapParsedPathKeyedSegment(segment) {
    return typeof segment == "object" && "_key" in segment && "_index" in segment;
}
function jsonPathToMappingPath(path) {
    return path.map((segment)=>{
        if (typeof segment == "string" || typeof segment == "number") return segment;
        if (segment._index !== -1) return segment._index;
        throw new Error(`invalid segment:${JSON.stringify(segment)}`);
    });
}
function resolveMapping(resultPath, csm) {
    if (!csm?.mappings) return;
    const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));
    if (csm.mappings[resultMappingPath] !== void 0) return {
        mapping: csm.mappings[resultMappingPath],
        matchedPath: resultMappingPath,
        pathSuffix: ""
    };
    const mappings = Object.entries(csm.mappings).filter(([key])=>resultMappingPath.startsWith(key)).sort(([key1], [key2])=>key2.length - key1.length);
    if (mappings.length == 0) return;
    const [matchedPath, mapping] = mappings[0], pathSuffix = resultMappingPath.substring(matchedPath.length);
    return {
        mapping,
        matchedPath,
        pathSuffix
    };
}
function isArray(value) {
    return value !== null && Array.isArray(value);
}
function isRecord(value) {
    return typeof value == "object" && value !== null;
}
function walkMap(value, mappingFn, path = []) {
    if (isArray(value)) return value.map((v, idx)=>{
        if (isRecord(v)) {
            const _key = v._key;
            if (typeof _key == "string") return walkMap(v, mappingFn, path.concat({
                _key,
                _index: idx
            }));
        }
        return walkMap(v, mappingFn, path.concat(idx));
    });
    if (isRecord(value)) {
        if (value._type === "block" || value._type === "span") {
            const result = {
                ...value
            };
            return value._type === "block" ? result.children = walkMap(value.children, mappingFn, path.concat("children")) : value._type === "span" && (result.text = walkMap(value.text, mappingFn, path.concat("text"))), result;
        }
        return Object.fromEntries(Object.entries(value).map(([k, v])=>[
                k,
                walkMap(v, mappingFn, path.concat(k))
            ]));
    }
    return mappingFn(value, path);
}
function createEditUrl(options) {
    const { baseUrl, workspace: _workspace = "default", tool: _tool = "default", id: _id, type, path, projectId, dataset } = options;
    if (!baseUrl) throw new Error("baseUrl is required");
    if (!path) throw new Error("path is required");
    if (!_id) throw new Error("id is required");
    if (baseUrl !== "/" && baseUrl.endsWith("/")) throw new Error("baseUrl must not end with a slash");
    const workspace = _workspace === "default" ? void 0 : _workspace, tool = _tool === "default" ? void 0 : _tool, id = getPublishedId(_id), stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path, searchParams = new URLSearchParams({
        baseUrl,
        id,
        type,
        path: stringifiedPath
    });
    if (workspace && searchParams.set("workspace", workspace), tool && searchParams.set("tool", tool), projectId && searchParams.set("projectId", projectId), dataset && searchParams.set("dataset", dataset), isPublishedId(_id)) searchParams.set("perspective", "published");
    else if (isVersionId(_id)) {
        const versionId = getVersionFromId(_id);
        searchParams.set("perspective", versionId);
    }
    const segments = [
        baseUrl === "/" ? "" : baseUrl
    ];
    workspace && segments.push(workspace);
    const routerParams = [
        "mode=presentation",
        `id=${id}`,
        `type=${type}`,
        `path=${encodeURIComponent(stringifiedPath)}`
    ];
    return tool && routerParams.push(`tool=${tool}`), segments.push("intent", "edit", `${routerParams.join(";")}?${searchParams}`), segments.join("/");
}
function resolveEditInfo(options) {
    const { resultSourceMap: csm, resultPath } = options, { mapping, pathSuffix } = resolveMapping(resultPath, csm) || {};
    if (!mapping || mapping.source.type === "literal" || mapping.source.type === "unknown") return;
    const sourceDoc = csm.documents[mapping.source.document], sourcePath = csm.paths[mapping.source.path];
    if (sourceDoc && sourcePath) {
        const { baseUrl, workspace, tool } = resolveStudioBaseRoute(typeof options.studioUrl == "function" ? options.studioUrl(sourceDoc) : options.studioUrl);
        if (!baseUrl) return;
        const { _id, _type, _projectId, _dataset } = sourceDoc;
        return {
            baseUrl,
            workspace,
            tool,
            id: _id,
            type: _type,
            path: parseJsonPath(sourcePath + pathSuffix),
            projectId: _projectId,
            dataset: _dataset
        };
    }
}
function resolveStudioBaseRoute(studioUrl) {
    let baseUrl = typeof studioUrl == "string" ? studioUrl : studioUrl.baseUrl;
    return baseUrl !== "/" && (baseUrl = baseUrl.replace(/\/$/, "")), typeof studioUrl == "string" ? {
        baseUrl
    } : {
        ...studioUrl,
        baseUrl
    };
}
;
 //# sourceMappingURL=resolveEditInfo.js.map
}}),
"[project]/node_modules/@sanity/visual-editing/dist/_chunks-es/context.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "actor": (()=>actor),
    "emptyActor": (()=>emptyActor),
    "isEmptyActor": (()=>isEmptyActor),
    "listeners": (()=>listeners),
    "setActor": (()=>setActor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$actors$2f$dist$2f$xstate$2d$actors$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/xstate/actors/dist/xstate-actors.development.esm.js [app-client] (ecmascript)");
;
const emptyActor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$actors$2f$dist$2f$xstate$2d$actors$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEmptyActor"])();
let actor = emptyActor;
const listeners = /* @__PURE__ */ new Set();
function isEmptyActor(actor2) {
    return actor2 === emptyActor;
}
function setActor(nextActor) {
    actor = nextActor;
    for (const onActorChange of listeners)onActorChange();
}
;
 //# sourceMappingURL=context.js.map
}}),
"[project]/node_modules/@sanity/mutate/dist/_chunks-es/parse.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "parse": (()=>parse)
});
function parse(path) {
    return path.split(/[[.\]]/g).filter(Boolean).map((seg)=>seg.includes("==") ? parseSegment(seg) : coerce(seg));
}
const IS_NUMERIC = /^-?\d+$/;
function unquote(str) {
    return str.replace(/^['"]/, "").replace(/['"]$/, "");
}
function parseSegment(segment) {
    const [key, value] = segment.split("==");
    if (key !== "_key") throw new Error(`Currently only "_key" is supported as path segment. Found ${key}`);
    if (typeof value > "u") throw new Error('Invalid path segment, expected `key=="value"`');
    return {
        _key: unquote(value)
    };
}
function coerce(segment) {
    return IS_NUMERIC.test(segment) ? Number(segment) : segment;
}
;
 //# sourceMappingURL=parse.js.map
}}),
"[project]/node_modules/@sanity/mutate/dist/_chunks-es/stringify.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "isArrayElement": (()=>isArrayElement),
    "isElementEqual": (()=>isElementEqual),
    "isEqual": (()=>isEqual),
    "isIndexElement": (()=>isIndexElement),
    "isKeyElement": (()=>isKeyElement),
    "isKeyedElement": (()=>isKeyedElement),
    "isPropertyElement": (()=>isPropertyElement),
    "startsWith": (()=>startsWith),
    "stringify": (()=>stringify)
});
function safeGetElementAt(array, index) {
    if (index < 0 || index >= array.length) throw new Error("Index out of bounds");
    return array[index];
}
function startsWith(parentPath, path) {
    return parentPath.length <= path.length && parentPath.every((segment, i)=>isElementEqual(segment, safeGetElementAt(path, i)));
}
function isEqual(path, otherPath) {
    return path.length === otherPath.length && path.every((segment, i)=>isElementEqual(segment, safeGetElementAt(path, i)));
}
function isElementEqual(segmentA, segmentB) {
    return isKeyElement(segmentA) && isKeyElement(segmentB) ? segmentA._key === segmentB._key : isIndexElement(segmentA) ? Number(segmentA) === Number(segmentB) : segmentA === segmentB;
}
function isKeyElement(segment) {
    return typeof segment?._key == "string";
}
function isIndexElement(segment) {
    return typeof segment == "number";
}
function isKeyedElement(element) {
    return typeof element == "object" && "_key" in element && typeof element._key == "string";
}
function isArrayElement(element) {
    return typeof element == "number" || isKeyedElement(element);
}
function isPropertyElement(element) {
    return typeof element == "string";
}
const IS_DOTTABLE = /^[a-z_$]+/;
function stringifySegment(segment, hasLeading) {
    return Array.isArray(segment) ? `[${segment[0]}:${segment[1] || ""}]` : typeof segment == "number" ? `[${segment}]` : isKeyedElement(segment) ? `[_key==${JSON.stringify(segment._key)}]` : typeof segment == "string" && IS_DOTTABLE.test(segment) ? hasLeading ? segment : `.${segment}` : `['${segment}']`;
}
function stringify(pathArray) {
    return pathArray.map((segment, i)=>stringifySegment(segment, i === 0)).join("");
}
;
 //# sourceMappingURL=stringify.js.map
}}),
"[project]/node_modules/@sanity/mutate/dist/_chunks-es/decode.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "decode": (()=>decode),
    "decodeAll": (()=>decodeAll)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/mutate/dist/_chunks-es/parse.js [app-client] (ecmascript)");
;
function isCreateIfNotExistsMutation(sanityMutation) {
    return "createIfNotExists" in sanityMutation;
}
function isCreateOrReplaceMutation(sanityMutation) {
    return "createOrReplace" in sanityMutation;
}
function isCreateMutation(sanityMutation) {
    return "create" in sanityMutation;
}
function isDeleteMutation(sanityMutation) {
    return "delete" in sanityMutation;
}
function isPatchMutation(sanityMutation) {
    return "patch" in sanityMutation;
}
function isSetPatch(sanityPatch) {
    return "set" in sanityPatch;
}
function isSetIfMissingPatch(sanityPatch) {
    return "setIfMissing" in sanityPatch;
}
function isUnsetPatch(sanityPatch) {
    return "unset" in sanityPatch;
}
function isIncPatch(sanityPatch) {
    return "inc" in sanityPatch;
}
function isDecPatch(sanityPatch) {
    return "inc" in sanityPatch;
}
function isInsertPatch(sanityPatch) {
    return "insert" in sanityPatch;
}
function decodeAll(sanityMutations) {
    return sanityMutations.map(decodeMutation);
}
function decode(encodedMutation) {
    return decodeMutation(encodedMutation);
}
function decodeMutation(encodedMutation) {
    if (isCreateIfNotExistsMutation(encodedMutation)) return {
        type: "createIfNotExists",
        document: encodedMutation.createIfNotExists
    };
    if (isCreateOrReplaceMutation(encodedMutation)) return {
        type: "createOrReplace",
        document: encodedMutation.createOrReplace
    };
    if (isCreateMutation(encodedMutation)) return {
        type: "create",
        document: encodedMutation.create
    };
    if (isDeleteMutation(encodedMutation)) return {
        id: encodedMutation.delete.id,
        type: "delete"
    };
    if (isPatchMutation(encodedMutation)) return {
        type: "patch",
        id: encodedMutation.patch.id,
        patches: decodeNodePatches(encodedMutation.patch)
    };
    throw new Error(`Unknown mutation: ${JSON.stringify(encodedMutation)}`);
}
const POSITION_KEYS = [
    "before",
    "replace",
    "after"
];
function getInsertPosition(insert) {
    const positions = POSITION_KEYS.filter((k)=>k in insert);
    if (positions.length > 1) throw new Error(`Insert patch is ambiguous. Should only contain one of: ${POSITION_KEYS.join(", ")}, instead found ${positions.join(", ")}`);
    return positions[0];
}
function decodeNodePatches(patch) {
    return [
        ...getSetPatches(patch),
        ...getSetIfMissingPatches(patch),
        ...getUnsetPatches(patch),
        ...getIncPatches(patch),
        ...getDecPatches(patch),
        ...getInsertPatches(patch)
    ];
}
function getSetPatches(patch) {
    return isSetPatch(patch) ? Object.keys(patch.set).map((path)=>({
            path: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(path),
            op: {
                type: "set",
                value: patch.set[path]
            }
        })) : [];
}
function getSetIfMissingPatches(patch) {
    return isSetIfMissingPatch(patch) ? Object.keys(patch.setIfMissing).map((path)=>({
            path: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(path),
            op: {
                type: "setIfMissing",
                value: patch.setIfMissing[path]
            }
        })) : [];
}
function getUnsetPatches(patch) {
    return isUnsetPatch(patch) ? patch.unset.map((path)=>({
            path: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(path),
            op: {
                type: "unset"
            }
        })) : [];
}
function getIncPatches(patch) {
    return isIncPatch(patch) ? Object.keys(patch.inc).map((path)=>({
            path: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(path),
            op: {
                type: "inc",
                amount: patch.inc[path]
            }
        })) : [];
}
function getDecPatches(patch) {
    return isDecPatch(patch) ? Object.keys(patch.dec).map((path)=>({
            path: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(path),
            op: {
                type: "dec",
                amount: patch.dec[path]
            }
        })) : [];
}
function getInsertPatches(patch) {
    if (!isInsertPatch(patch)) return [];
    const position = getInsertPosition(patch.insert);
    if (!position) throw new Error("Insert patch missing position");
    const path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(patch.insert[position]), referenceItem = path.pop(), op = position === "replace" ? {
        type: "insert",
        position,
        referenceItem,
        items: patch.insert.items
    } : {
        type: "insert",
        position,
        referenceItem,
        items: patch.insert.items
    };
    return [
        {
            path,
            op
        }
    ];
}
;
 //# sourceMappingURL=decode.js.map
}}),
"[project]/node_modules/@sanity/mutate/dist/_chunks-es/encode.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "encode": (()=>encode),
    "encodeAll": (()=>encodeAll),
    "encodeMutation": (()=>encodeMutation),
    "encodeTransaction": (()=>encodeTransaction)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/mutate/dist/_chunks-es/stringify.js [app-client] (ecmascript)");
;
function encode(mutation) {
    return encodeMutation(mutation);
}
function encodeAll(mutations) {
    return mutations.flatMap(encode);
}
function encodeTransaction(transaction) {
    return {
        transactionId: transaction.id,
        mutations: encodeAll(transaction.mutations)
    };
}
function encodeMutation(mutation) {
    if (mutation.type === "create" || mutation.type === "createIfNotExists" || mutation.type === "createOrReplace") return {
        [mutation.type]: mutation.document
    };
    if (mutation.type === "delete") return {
        delete: {
            id: mutation.id
        }
    };
    const ifRevisionID = mutation.options?.ifRevision;
    return mutation.patches.map((patch)=>({
            patch: {
                id: mutation.id,
                ...ifRevisionID && {
                    ifRevisionID
                },
                ...patchToSanity(patch)
            }
        }));
}
function patchToSanity(patch) {
    const { path, op } = patch;
    if (op.type === "unset") return {
        unset: [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(path)
        ]
    };
    if (op.type === "insert") return {
        insert: {
            [op.position]: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])([
                ...path,
                op.referenceItem
            ]),
            items: op.items
        }
    };
    if (op.type === "diffMatchPatch") return {
        diffMatchPatch: {
            [(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(path)]: op.value
        }
    };
    if (op.type === "inc") return {
        inc: {
            [(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(path)]: op.amount
        }
    };
    if (op.type === "dec") return {
        dec: {
            [(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(path)]: op.amount
        }
    };
    if (op.type === "set" || op.type === "setIfMissing") return {
        [op.type]: {
            [(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(path)]: op.value
        }
    };
    if (op.type === "truncate") {
        const range = [
            op.startIndex,
            typeof op.endIndex == "number" ? op.endIndex : ""
        ].join(":");
        return {
            unset: [
                `${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(path)}[${range}]`
            ]
        };
    }
    if (op.type === "upsert") return {
        unset: op.items.map((item)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])([
                ...path,
                {
                    _key: item._key
                }
            ])),
        insert: {
            [op.position]: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])([
                ...path,
                op.referenceItem
            ]),
            items: op.items
        }
    };
    if (op.type === "assign") return {
        set: Object.fromEntries(Object.keys(op.value).map((key)=>[
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(path.concat(key)),
                op.value[key]
            ]))
    };
    if (op.type === "unassign") return {
        unset: op.keys.map((key)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(path.concat(key)))
    };
    if (op.type === "replace") return {
        insert: {
            replace: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(path.concat(op.referenceItem)),
            items: op.items
        }
    };
    if (op.type === "remove") return {
        unset: [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(path.concat(op.referenceItem))
        ]
    };
    throw new Error(`Unknown operation type ${op.type}`);
}
;
 //# sourceMappingURL=encode.js.map
}}),
"[project]/node_modules/@sanity/mutate/dist/_chunks-es/isObject.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "isObject": (()=>isObject)
});
function isObject(val) {
    return val !== null && typeof val == "object" && !Array.isArray(val);
}
;
 //# sourceMappingURL=isObject.js.map
}}),
"[project]/node_modules/@sanity/mutate/dist/_chunks-es/arrify.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "arrify": (()=>arrify)
});
function arrify(val) {
    return Array.isArray(val) ? val : [
        val
    ];
}
;
 //# sourceMappingURL=arrify.js.map
}}),
"[project]/node_modules/@sanity/mutate/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "CompactEncoder": (()=>index$1),
    "CompactFormatter": (()=>compact),
    "SanityEncoder": (()=>index),
    "append": (()=>append),
    "assign": (()=>assign),
    "at": (()=>at),
    "autoKeys": (()=>autoKeys),
    "create": (()=>create),
    "createIfNotExists": (()=>createIfNotExists),
    "createOrReplace": (()=>createOrReplace),
    "dec": (()=>dec),
    "del": (()=>del),
    "delete_": (()=>delete_),
    "destroy": (()=>destroy),
    "diffMatchPatch": (()=>diffMatchPatch),
    "inc": (()=>inc),
    "insert": (()=>insert),
    "insertAfter": (()=>insertAfter),
    "insertBefore": (()=>insertBefore),
    "patch": (()=>patch),
    "prepend": (()=>prepend),
    "remove": (()=>remove),
    "replace": (()=>replace),
    "set": (()=>set),
    "setIfMissing": (()=>setIfMissing),
    "truncate": (()=>truncate),
    "unassign": (()=>unassign),
    "unset": (()=>unset),
    "upsert": (()=>upsert)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/mutate/dist/_chunks-es/parse.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/mutate/dist/_chunks-es/stringify.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/mutate/dist/_chunks-es/decode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/mutate/dist/_chunks-es/encode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$isObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/mutate/dist/_chunks-es/isObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$arrify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/mutate/dist/_chunks-es/arrify.js [app-client] (ecmascript)");
;
;
;
;
;
;
function decode(mutations) {
    return mutations.map(decodeMutation);
}
function decodeMutation(mutation) {
    const [type] = mutation;
    if (type === "delete") {
        const [, id] = mutation;
        return {
            id,
            type
        };
    } else if (type === "create") {
        const [, document] = mutation;
        return {
            type,
            document
        };
    } else if (type === "createIfNotExists") {
        const [, document] = mutation;
        return {
            type,
            document
        };
    } else if (type === "createOrReplace") {
        const [, document] = mutation;
        return {
            type,
            document
        };
    } else if (type === "patch") return decodePatchMutation(mutation);
    throw new Error(`Unrecognized mutation: ${JSON.stringify(mutation)}`);
}
function decodePatchMutation(mutation) {
    const [, type, id, serializedPath, , revisionId] = mutation, path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(serializedPath);
    if (type === "dec" || type === "inc") {
        const [, , , , [amount]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "inc",
                        amount
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "unset") return {
        type: "patch",
        id,
        patches: [
            {
                path,
                op: {
                    type: "unset"
                }
            }
        ],
        ...createOpts(revisionId)
    };
    if (type === "insert") {
        const [, , , , [position, ref, items]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "insert",
                        position,
                        items,
                        referenceItem: typeof ref == "string" ? {
                            _key: ref
                        } : ref
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "set") {
        const [, , , , [value]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "set",
                        value
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "setIfMissing") {
        const [, , , , [value]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "setIfMissing",
                        value
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "diffMatchPatch") {
        const [, , , , [value]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "diffMatchPatch",
                        value
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "truncate") {
        const [, , , , [startIndex, endIndex]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "truncate",
                        startIndex,
                        endIndex
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "assign") {
        const [, , , , [value]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "assign",
                        value
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "replace") {
        const [, , , , [ref, items]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "replace",
                        items,
                        referenceItem: decodeItemRef(ref)
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    if (type === "upsert") {
        const [, , , , [position, referenceItem, items]] = mutation;
        return {
            type: "patch",
            id,
            patches: [
                {
                    path,
                    op: {
                        type: "upsert",
                        items,
                        referenceItem: decodeItemRef(referenceItem),
                        position
                    }
                }
            ],
            ...createOpts(revisionId)
        };
    }
    throw new Error(`Invalid mutation type: ${type}`);
}
function decodeItemRef(ref) {
    return typeof ref == "string" ? {
        _key: ref
    } : ref;
}
function createOpts(revisionId) {
    return revisionId ? {
        options: {
            ifRevision: revisionId
        }
    } : null;
}
function encode(mutations) {
    return mutations.flatMap((m)=>encodeMutation$1(m));
}
function encodeItemRef$1(ref) {
    return typeof ref == "number" ? ref : ref._key;
}
function encodeMutation$1(mutation) {
    if (mutation.type === "create" || mutation.type === "createIfNotExists" || mutation.type === "createOrReplace") return [
        [
            mutation.type,
            mutation.document
        ]
    ];
    if (mutation.type === "delete") return [
        [
            "delete",
            mutation.id
        ]
    ];
    if (mutation.type === "patch") return mutation.patches.map((patch2)=>maybeAddRevision(mutation.options?.ifRevision, encodePatchMutation(mutation.id, patch2)));
    throw new Error(`Invalid mutation type: ${mutation.type}`);
}
function encodePatchMutation(id, patch2) {
    const { op } = patch2, path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(patch2.path);
    if (op.type === "unset") return [
        "patch",
        "unset",
        id,
        path,
        []
    ];
    if (op.type === "diffMatchPatch") return [
        "patch",
        "diffMatchPatch",
        id,
        path,
        [
            op.value
        ]
    ];
    if (op.type === "inc" || op.type === "dec") return [
        "patch",
        op.type,
        id,
        path,
        [
            op.amount
        ]
    ];
    if (op.type === "set") return [
        "patch",
        op.type,
        id,
        path,
        [
            op.value
        ]
    ];
    if (op.type === "setIfMissing") return [
        "patch",
        op.type,
        id,
        path,
        [
            op.value
        ]
    ];
    if (op.type === "insert") return [
        "patch",
        "insert",
        id,
        path,
        [
            op.position,
            encodeItemRef$1(op.referenceItem),
            op.items
        ]
    ];
    if (op.type === "upsert") return [
        "patch",
        "upsert",
        id,
        path,
        [
            op.position,
            encodeItemRef$1(op.referenceItem),
            op.items
        ]
    ];
    if (op.type === "assign") return [
        "patch",
        "assign",
        id,
        path,
        [
            op.value
        ]
    ];
    if (op.type === "unassign") return [
        "patch",
        "assign",
        id,
        path,
        [
            op.keys
        ]
    ];
    if (op.type === "replace") return [
        "patch",
        "replace",
        id,
        path,
        [
            encodeItemRef$1(op.referenceItem),
            op.items
        ]
    ];
    if (op.type === "truncate") return [
        "patch",
        "truncate",
        id,
        path,
        [
            op.startIndex,
            op.endIndex
        ]
    ];
    if (op.type === "remove") return [
        "patch",
        "remove",
        id,
        path,
        [
            encodeItemRef$1(op.referenceItem)
        ]
    ];
    throw new Error(`Invalid operation type: ${op.type}`);
}
function maybeAddRevision(revision, mut) {
    const [mutType, patchType, id, path, args] = mut;
    return revision ? [
        mutType,
        patchType,
        id,
        path,
        args,
        revision
    ] : mut;
}
var index$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    decode,
    encode
}), index = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    decode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"],
    decodeAll: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeAll"],
    encode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"],
    encodeAll: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeAll"],
    encodeMutation: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeMutation"],
    encodeTransaction: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeTransaction"]
});
function format(mutations) {
    return mutations.flatMap((m)=>encodeMutation(m)).join(`
`);
}
function encodeItemRef(ref) {
    return typeof ref == "number" ? ref : ref._key;
}
function encodeMutation(mutation) {
    if (mutation.type === "create" || mutation.type === "createIfNotExists" || mutation.type === "createOrReplace") return [
        mutation.type,
        ": ",
        JSON.stringify(mutation.document)
    ].join("");
    if (mutation.type === "delete") return [
        "delete ",
        mutation.id
    ].join(": ");
    if (mutation.type === "patch") {
        const ifRevision = mutation.options?.ifRevision;
        return [
            "patch",
            " ",
            `id=${mutation.id}`,
            ifRevision ? ` (if revision==${ifRevision})` : "",
            `:
`,
            mutation.patches.map((nodePatch)=>`  ${formatPatchMutation(nodePatch)}`).join(`
`)
        ].join("");
    }
    throw new Error(`Invalid mutation type: ${mutation.type}`);
}
function formatPatchMutation(patch2) {
    const { op } = patch2, path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(patch2.path);
    if (op.type === "unset") return [
        path,
        "unset()"
    ].join(": ");
    if (op.type === "diffMatchPatch") return [
        path,
        `diffMatchPatch(${op.value})`
    ].join(": ");
    if (op.type === "inc" || op.type === "dec") return [
        path,
        `${op.type}(${op.amount})`
    ].join(": ");
    if (op.type === "set" || op.type === "setIfMissing") return [
        path,
        `${op.type}(${JSON.stringify(op.value)})`
    ].join(": ");
    if (op.type === "assign") return [
        path,
        `${op.type}(${JSON.stringify(op.value)})`
    ].join(": ");
    if (op.type === "unassign") return [
        path,
        `${op.type}(${JSON.stringify(op.keys)})`
    ].join(": ");
    if (op.type === "insert" || op.type === "upsert") return [
        path,
        `${op.type}(${op.position}, ${encodeItemRef(op.referenceItem)}, ${JSON.stringify(op.items)})`
    ].join(": ");
    if (op.type === "replace") return [
        path,
        `replace(${encodeItemRef(op.referenceItem)}, ${JSON.stringify(op.items)})`
    ].join(": ");
    if (op.type === "truncate") return [
        path,
        `truncate(${op.startIndex}, ${op.endIndex}`
    ].join(": ");
    if (op.type === "remove") return [
        path,
        `remove(${encodeItemRef(op.referenceItem)})`
    ].join(": ");
    throw new Error(`Invalid operation type: ${op.type}`);
}
var compact = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    format
});
const set = (value)=>({
        type: "set",
        value
    }), assign = (value)=>({
        type: "assign",
        value
    }), unassign = (keys)=>({
        type: "unassign",
        keys
    }), setIfMissing = (value)=>({
        type: "setIfMissing",
        value
    }), unset = ()=>({
        type: "unset"
    }), inc = (amount = 1)=>({
        type: "inc",
        amount
    }), dec = (amount = 1)=>({
        type: "dec",
        amount
    }), diffMatchPatch = (value)=>({
        type: "diffMatchPatch",
        value
    });
function insert(items, position, indexOrReferenceItem) {
    return {
        type: "insert",
        referenceItem: indexOrReferenceItem,
        position,
        items: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$arrify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrify"])(items)
    };
}
function append(items) {
    return insert(items, "after", -1);
}
function prepend(items) {
    return insert(items, "before", 0);
}
function insertBefore(items, indexOrReferenceItem) {
    return insert(items, "before", indexOrReferenceItem);
}
const insertAfter = (items, indexOrReferenceItem)=>insert(items, "after", indexOrReferenceItem);
function truncate(startIndex, endIndex) {
    return {
        type: "truncate",
        startIndex,
        endIndex
    };
}
function replace(items, referenceItem) {
    return {
        type: "replace",
        referenceItem,
        items: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$arrify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrify"])(items)
    };
}
function remove(referenceItem) {
    return {
        type: "remove",
        referenceItem
    };
}
function upsert(items, position, referenceItem) {
    return {
        type: "upsert",
        items: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$arrify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrify"])(items),
        referenceItem,
        position
    };
}
function autoKeys(generateKey) {
    const ensureKeys = createEnsureKeys(generateKey), insert$1 = (position, referenceItem, items)=>insert(ensureKeys(items), position, referenceItem), upsert$1 = (items, position, referenceItem)=>upsert(ensureKeys(items), position, referenceItem), replace$1 = (items, position, referenceItem)=>replace(ensureKeys(items), referenceItem), insertBefore2 = (ref, items)=>insert$1("before", ref, items);
    return {
        insert: insert$1,
        upsert: upsert$1,
        replace: replace$1,
        insertBefore: insertBefore2,
        prepend: (items)=>insertBefore2(0, items),
        insertAfter: (ref, items)=>insert$1("after", ref, items),
        append: (items)=>insert$1("after", -1, items)
    };
}
function hasKey(item) {
    return "_key" in item;
}
function createEnsureKeys(generateKey) {
    return (array)=>{
        let didModify = !1;
        const withKeys = array.map((item)=>needsKey(item) ? (didModify = !0, {
                ...item,
                _key: generateKey(item)
            }) : item);
        return didModify ? withKeys : array;
    };
}
function needsKey(arrayItem) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$isObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(arrayItem) && !hasKey(arrayItem);
}
function create(document) {
    return {
        type: "create",
        document
    };
}
function patch(id, patches, options) {
    return {
        type: "patch",
        id,
        patches: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$arrify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrify"])(patches),
        ...options ? {
            options
        } : {}
    };
}
function at(path, operation) {
    return {
        path: typeof path == "string" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$_chunks$2d$es$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(path) : path,
        op: operation
    };
}
function createIfNotExists(document) {
    return {
        type: "createIfNotExists",
        document
    };
}
function createOrReplace(document) {
    return {
        type: "createOrReplace",
        document
    };
}
function delete_(id) {
    return {
        type: "delete",
        id
    };
}
const del = delete_, destroy = delete_;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/get-random-values-esm/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Strict ESM env, designed to run outside Node.js in envs that provide WebCrypto (deno, browsers, etc)
__turbopack_context__.s({
    "default": (()=>getRandomValues)
});
function getRandomValues(typedArray) {
    const crypto = typeof window !== 'undefined' && 'crypto' in window ? window.crypto : globalThis.crypto;
    if (!crypto || !crypto.getRandomValues) {
        throw new Error('WebCrypto not available in this environment');
    }
    return crypto.getRandomValues(typedArray);
}
}}),
"[project]/node_modules/@sanity/visual-editing/dist/_chunks-es/mutations.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "get": (()=>get),
    "getArrayDuplicatePatches": (()=>getArrayDuplicatePatches),
    "getArrayInsertPatches": (()=>getArrayInsertPatches),
    "getArrayItemKeyAndParentPath": (()=>getArrayItemKeyAndParentPath),
    "getArrayMovePatches": (()=>getArrayMovePatches),
    "getArrayRemovePatches": (()=>getArrayRemovePatches),
    "useDocuments": (()=>useDocuments),
    "useOptimisticActor": (()=>useOptimisticActor),
    "useOptimisticActorReady": (()=>useOptimisticActorReady)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-compiler-runtime/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/client/dist/_chunks-es/resolveEditInfo.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/mutate/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2d$comlink$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@sanity/presentation-comlink/dist/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/visual-editing/dist/_chunks-es/context.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react-experimental/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$random$2d$values$2d$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/get-random-values-esm/index.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
;
const reKeySegment$1 = /_key\s*==\s*['"](.*)['"]/, reIndexTuple = /^\d*:\d*$/;
function isIndexSegment(segment) {
    return typeof segment == "number" || typeof segment == "string" && /^\[\d+\]$/.test(segment);
}
function isKeySegment(segment) {
    return typeof segment == "string" ? reKeySegment$1.test(segment.trim()) : typeof segment == "object" && "_key" in segment;
}
function isIndexTuple(segment) {
    if (typeof segment == "string" && reIndexTuple.test(segment)) return !0;
    if (!Array.isArray(segment) || segment.length !== 2) return !1;
    const [from, to] = segment;
    return (typeof from == "number" || from === "") && (typeof to == "number" || to === "");
}
const rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reKeySegment = /_key\s*==\s*['"](.*)['"]/;
function get(obj, path, defaultVal) {
    const select = typeof path == "string" ? fromString(path) : path;
    if (!Array.isArray(select)) throw new Error("Path must be an array or a string");
    let acc = obj;
    for(let i = 0; i < select.length; i++){
        const segment = select[i];
        if (isIndexSegment(segment)) {
            if (!Array.isArray(acc)) return defaultVal;
            acc = acc[segment];
        }
        if (isKeySegment(segment)) {
            if (!Array.isArray(acc)) return defaultVal;
            acc = acc.find((item)=>item._key === segment._key);
        }
        if (typeof segment == "string" && (acc = typeof acc == "object" && acc !== null ? acc[segment] : void 0), typeof acc > "u") return defaultVal;
    }
    return acc;
}
function fromString(path) {
    if (typeof path != "string") throw new Error("Path is not a string");
    const segments = path.match(rePropName);
    if (!segments) throw new Error("Invalid path string");
    return segments.map(normalizePathSegment);
}
function normalizePathSegment(segment) {
    return isIndexSegment(segment) ? normalizeIndexSegment(segment) : isKeySegment(segment) ? normalizeKeySegment(segment) : isIndexTuple(segment) ? normalizeIndexTupleSegment(segment) : segment;
}
function normalizeIndexSegment(segment) {
    return Number(segment.replace(/[^\d]/g, ""));
}
function normalizeKeySegment(segment) {
    return {
        _key: segment.match(reKeySegment)[1]
    };
}
function normalizeIndexTupleSegment(segment) {
    const [from, to] = segment.split(":").map((seg)=>seg === "" ? seg : Number(seg));
    return [
        from,
        to
    ];
}
function useOptimisticActor() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(_temp, _temp2, _temp3);
}
function _temp3() {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["emptyActor"];
}
function _temp2() {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["actor"];
}
function _temp(listener) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["listeners"].add(listener), ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["listeners"].delete(listener);
}
function useOptimisticActorReady() {
    const actor2 = useOptimisticActor();
    let t0;
    return t0 = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEmptyActor"])(actor2), t0;
}
function debounce(fn, timeout) {
    let timer;
    return (...args)=>{
        clearTimeout(timer), timer = setTimeout(()=>{
            fn.apply(fn, args);
        }, timeout);
    };
}
function getDocumentsAndSnapshot(id, actor2) {
    const inFrame = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2d$comlink$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isMaybePreviewIframe"])(), inPopUp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2d$comlink$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isMaybePreviewWindow"])();
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEmptyActor"])(actor2) || !inFrame && !inPopUp) throw new Error("The `useDocuments` hook cannot be used in this context");
    const draftId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDraftId"])(id), publishedId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPublishedId"])(id), documents = actor2.getSnapshot().context?.documents, draftDoc = documents?.[draftId], publishedDoc = documents?.[publishedId], doc = draftDoc || publishedDoc;
    if (!doc) throw new Error(`Document "${id}" not found`);
    const snapshot = draftDoc.getSnapshot().context?.local || publishedDoc.getSnapshot().context?.local, snapshotPromise = new Promise((resolve)=>{
        if (snapshot) resolve(snapshot);
        else {
            const subscriber = doc.on("ready", (event)=>{
                const { snapshot: snapshot2 } = event;
                resolve(snapshot2 || null), subscriber.unsubscribe();
            });
        }
    });
    return {
        draftDoc,
        draftId,
        getSnapshot: ()=>snapshotPromise,
        publishedDoc,
        publishedId,
        /**
     * @deprecated - use `getSnapshot` instead
     */ get snapshot () {
            if (!snapshot) throw new Error(`Snapshot for document "${id}" not found`);
            return snapshot;
        }
    };
}
function createDocumentCommit(id, actor2) {
    return ()=>{
        const { draftDoc } = getDocumentsAndSnapshot(id, actor2);
        draftDoc.send({
            type: "submit"
        });
    };
}
function createDocumentGet(id, actor2) {
    return (path)=>{
        const { snapshot } = getDocumentsAndSnapshot(id, actor2);
        return path ? get(snapshot, path) : snapshot;
    };
}
function createDocumentGetSnapshot(id, actor2) {
    const { getSnapshot } = getDocumentsAndSnapshot(id, actor2);
    return getSnapshot;
}
function createDocumentPatch(id, actor2) {
    return async (patches, options)=>{
        const result = getDocumentsAndSnapshot(id, actor2), { draftDoc, draftId, getSnapshot, publishedId } = result, { commit = !0 } = options || {}, resolvedPatches = await (typeof patches == "function" ? patches({
            draftId,
            publishedId,
            /**
       * @deprecated - use `getSnapshot` instead
       */ get snapshot () {
                return result.snapshot;
            },
            getSnapshot
        }) : patches), _snapshot = await getSnapshot();
        if (!_snapshot) throw new Error(`Snapshot for document "${id}" not found`);
        draftDoc.send({
            type: "mutate",
            mutations: [
                // Attempt to create the draft document, it might not exist if the
                // snapshot was from the published document
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createIfNotExists"])({
                    ..._snapshot,
                    _id: draftId
                }),
                // Patch the draft document with the resolved patches
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["patch"])(draftId, resolvedPatches)
            ]
        }), commit && (typeof commit == "object" && "debounce" in commit ? debounce(()=>draftDoc.send({
                type: "submit"
            }), commit.debounce)() : draftDoc.send({
            type: "submit"
        }));
    };
}
function useDocuments() {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(7), actor2 = useOptimisticActor();
    let t0;
    $[0] !== actor2 ? (t0 = (documentId)=>({
            id: documentId,
            commit: createDocumentCommit(documentId, actor2),
            get: createDocumentGet(documentId, actor2),
            getSnapshot: createDocumentGetSnapshot(documentId, actor2),
            patch: createDocumentPatch(documentId, actor2)
        }), $[0] = actor2, $[1] = t0) : t0 = $[1];
    const getDocument = t0;
    let t1;
    $[2] !== actor2 ? (t1 = (id, mutations, options)=>{
        const { draftDoc } = getDocumentsAndSnapshot(id, actor2), { commit: t22 } = options || {}, commit = t22 === void 0 ? !0 : t22;
        draftDoc.send({
            type: "mutate",
            mutations
        }), commit && (typeof commit == "object" && "debounce" in commit ? debounce(()=>draftDoc.send({
                type: "submit"
            }), commit.debounce)() : draftDoc.send({
            type: "submit"
        }));
    }, $[2] = actor2, $[3] = t1) : t1 = $[3];
    const mutateDocument = t1;
    let t2;
    return $[4] !== getDocument || $[5] !== mutateDocument ? (t2 = {
        getDocument,
        mutateDocument
    }, $[4] = getDocument, $[5] = mutateDocument, $[6] = t2) : t2 = $[6], t2;
}
function whatwgRNG(length = 16) {
    const rnds8 = new Uint8Array(length);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$random$2d$values$2d$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(rnds8), rnds8;
}
const getByteHexTable = /* @__PURE__ */ (()=>{
    let table;
    return ()=>{
        if (table) return table;
        table = [];
        for(let i = 0; i < 256; ++i)table[i] = (i + 256).toString(16).slice(1);
        return table;
    };
})();
function randomKey(length) {
    const table = getByteHexTable();
    return whatwgRNG(length).reduce((str, n)=>str + table[n], "").slice(0, length);
}
function getArrayItemKeyAndParentPath(pathOrNode) {
    const elementPath = typeof pathOrNode == "string" ? pathOrNode : pathOrNode.path, lastDotIndex = elementPath.lastIndexOf("."), lastPathItem = elementPath.substring(lastDotIndex + 1, elementPath.length);
    if (!lastPathItem.indexOf("[")) throw new Error("Invalid path: not an array");
    const lastArrayIndex = elementPath.lastIndexOf("["), path = elementPath.substring(0, lastArrayIndex);
    let key, hasExplicitKey;
    if (lastPathItem.includes("_key")) {
        const startIndex = lastPathItem.indexOf('"') + 1, endIndex = lastPathItem.indexOf('"', startIndex);
        key = lastPathItem.substring(startIndex, endIndex), hasExplicitKey = !0;
    } else {
        const startIndex = lastPathItem.indexOf("[") + 1, endIndex = lastPathItem.indexOf("]", startIndex);
        key = lastPathItem.substring(startIndex, endIndex), hasExplicitKey = !1;
    }
    if (!path || !key) throw new Error("Invalid path");
    return {
        path,
        key,
        hasExplicitKey
    };
}
function getArrayDuplicatePatches(node, snapshot, position = "after") {
    const { path: arrayPath, key: itemKey } = getArrayItemKeyAndParentPath(node), duplicate = {
        ...get(snapshot, node.path),
        _key: randomKey()
    };
    return [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["at"])(arrayPath, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["insert"])(duplicate, position, {
            _key: itemKey
        }))
    ];
}
function getArrayRemovePatches(node, snapshot) {
    const { path: arrayPath, key: itemKey } = getArrayItemKeyAndParentPath(node), currentIndex = get(snapshot, arrayPath).findIndex((item)=>item._key === itemKey);
    return [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["at"])(arrayPath, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["truncate"])(currentIndex, currentIndex + 1))
    ];
}
function getArrayInsertPatches(node, insertType, position) {
    const { path: arrayPath, key: itemKey } = getArrayItemKeyAndParentPath(node), insertKey = randomKey();
    return [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["at"])(arrayPath, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["insert"])([
            {
                _type: insertType,
                _key: insertKey
            }
        ], position, {
            _key: itemKey
        }))
    ];
}
async function getArrayMovePatches(node, doc, moveTo) {
    if (!node.type) throw new Error("Node type is missing");
    const { path: arrayPath, key: itemKey } = getArrayItemKeyAndParentPath(node), snapshot = await doc.getSnapshot(), array = get(snapshot, arrayPath), item = get(snapshot, node.path), currentIndex = array.findIndex((item2)=>item2._key === itemKey);
    let nextIndex = -1, position = "before";
    if (moveTo === "first") {
        if (currentIndex === 0) return [];
        nextIndex = 0, position = "before";
    } else if (moveTo === "last") {
        if (currentIndex === array.length - 1) return [];
        nextIndex = -1, position = "after";
    } else if (moveTo === "next") {
        if (currentIndex === array.length - 1) return [];
        nextIndex = currentIndex, position = "after";
    } else if (moveTo === "previous") {
        if (currentIndex === 0) return [];
        nextIndex = currentIndex - 1, position = "before";
    }
    return [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["at"])(arrayPath, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["truncate"])(currentIndex, currentIndex + 1)),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["at"])(arrayPath, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$mutate$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["insert"])(item, position, nextIndex))
    ];
}
;
 //# sourceMappingURL=mutations.js.map
}}),
"[project]/node_modules/valibot/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/regex.ts
__turbopack_context__.s({
    "BIC_REGEX": (()=>BIC_REGEX),
    "CUID2_REGEX": (()=>CUID2_REGEX),
    "DECIMAL_REGEX": (()=>DECIMAL_REGEX),
    "EMAIL_REGEX": (()=>EMAIL_REGEX),
    "EMOJI_REGEX": (()=>EMOJI_REGEX),
    "HEXADECIMAL_REGEX": (()=>HEXADECIMAL_REGEX),
    "HEX_COLOR_REGEX": (()=>HEX_COLOR_REGEX),
    "IMEI_REGEX": (()=>IMEI_REGEX),
    "IPV4_REGEX": (()=>IPV4_REGEX),
    "IPV6_REGEX": (()=>IPV6_REGEX),
    "IP_REGEX": (()=>IP_REGEX),
    "ISO_DATE_REGEX": (()=>ISO_DATE_REGEX),
    "ISO_DATE_TIME_REGEX": (()=>ISO_DATE_TIME_REGEX),
    "ISO_TIMESTAMP_REGEX": (()=>ISO_TIMESTAMP_REGEX),
    "ISO_TIME_REGEX": (()=>ISO_TIME_REGEX),
    "ISO_TIME_SECOND_REGEX": (()=>ISO_TIME_SECOND_REGEX),
    "ISO_WEEK_REGEX": (()=>ISO_WEEK_REGEX),
    "MAC48_REGEX": (()=>MAC48_REGEX),
    "MAC64_REGEX": (()=>MAC64_REGEX),
    "MAC_REGEX": (()=>MAC_REGEX),
    "OCTAL_REGEX": (()=>OCTAL_REGEX),
    "ULID_REGEX": (()=>ULID_REGEX),
    "UUID_REGEX": (()=>UUID_REGEX),
    "ValiError": (()=>ValiError),
    "_addIssue": (()=>_addIssue),
    "_isAllowedObjectKey": (()=>_isAllowedObjectKey),
    "_isLuhnAlgo": (()=>_isLuhnAlgo),
    "_stringify": (()=>_stringify),
    "any": (()=>any),
    "array": (()=>array),
    "arrayAsync": (()=>arrayAsync),
    "bic": (()=>bic),
    "bigint": (()=>bigint),
    "blob": (()=>blob),
    "boolean": (()=>boolean),
    "brand": (()=>brand),
    "bytes": (()=>bytes),
    "check": (()=>check),
    "checkAsync": (()=>checkAsync),
    "config": (()=>config),
    "creditCard": (()=>creditCard),
    "cuid2": (()=>cuid2),
    "custom": (()=>custom),
    "customAsync": (()=>customAsync),
    "date": (()=>date),
    "decimal": (()=>decimal),
    "deleteGlobalConfig": (()=>deleteGlobalConfig),
    "deleteGlobalMessage": (()=>deleteGlobalMessage),
    "deleteSchemaMessage": (()=>deleteSchemaMessage),
    "deleteSpecificMessage": (()=>deleteSpecificMessage),
    "email": (()=>email),
    "emoji": (()=>emoji),
    "empty": (()=>empty),
    "endsWith": (()=>endsWith),
    "entriesFromList": (()=>entriesFromList),
    "enum_": (()=>enum_),
    "every": (()=>every),
    "excludes": (()=>excludes),
    "fallback": (()=>fallback),
    "fallbackAsync": (()=>fallbackAsync),
    "finite": (()=>finite),
    "flatten": (()=>flatten),
    "forward": (()=>forward),
    "forwardAsync": (()=>forwardAsync),
    "getDefault": (()=>getDefault),
    "getDefaults": (()=>getDefaults),
    "getDefaultsAsync": (()=>getDefaultsAsync),
    "getDotPath": (()=>getDotPath),
    "getFallback": (()=>getFallback),
    "getFallbacks": (()=>getFallbacks),
    "getFallbacksAsync": (()=>getFallbacksAsync),
    "getGlobalConfig": (()=>getGlobalConfig),
    "getGlobalMessage": (()=>getGlobalMessage),
    "getSchemaMessage": (()=>getSchemaMessage),
    "getSpecificMessage": (()=>getSpecificMessage),
    "hash": (()=>hash),
    "hexColor": (()=>hexColor),
    "hexadecimal": (()=>hexadecimal),
    "imei": (()=>imei),
    "includes": (()=>includes),
    "instance": (()=>instance),
    "integer": (()=>integer),
    "intersect": (()=>intersect),
    "intersectAsync": (()=>intersectAsync),
    "ip": (()=>ip),
    "ipv4": (()=>ipv4),
    "ipv6": (()=>ipv6),
    "is": (()=>is),
    "isOfKind": (()=>isOfKind),
    "isOfType": (()=>isOfType),
    "isValiError": (()=>isValiError),
    "isoDate": (()=>isoDate),
    "isoDateTime": (()=>isoDateTime),
    "isoTime": (()=>isoTime),
    "isoTimeSecond": (()=>isoTimeSecond),
    "isoTimestamp": (()=>isoTimestamp),
    "isoWeek": (()=>isoWeek),
    "keyof": (()=>keyof),
    "lazy": (()=>lazy),
    "lazyAsync": (()=>lazyAsync),
    "length": (()=>length),
    "literal": (()=>literal),
    "looseObject": (()=>looseObject),
    "looseObjectAsync": (()=>looseObjectAsync),
    "looseTuple": (()=>looseTuple),
    "looseTupleAsync": (()=>looseTupleAsync),
    "mac": (()=>mac),
    "mac48": (()=>mac48),
    "mac64": (()=>mac64),
    "map": (()=>map),
    "mapAsync": (()=>mapAsync),
    "maxBytes": (()=>maxBytes),
    "maxLength": (()=>maxLength),
    "maxSize": (()=>maxSize),
    "maxValue": (()=>maxValue),
    "mimeType": (()=>mimeType),
    "minBytes": (()=>minBytes),
    "minLength": (()=>minLength),
    "minSize": (()=>minSize),
    "minValue": (()=>minValue),
    "multipleOf": (()=>multipleOf),
    "nan": (()=>nan),
    "never": (()=>never),
    "nonEmpty": (()=>nonEmpty),
    "nonNullable": (()=>nonNullable),
    "nonNullableAsync": (()=>nonNullableAsync),
    "nonNullish": (()=>nonNullish),
    "nonNullishAsync": (()=>nonNullishAsync),
    "nonOptional": (()=>nonOptional),
    "nonOptionalAsync": (()=>nonOptionalAsync),
    "notBytes": (()=>notBytes),
    "notLength": (()=>notLength),
    "notSize": (()=>notSize),
    "notValue": (()=>notValue),
    "null_": (()=>null_),
    "nullable": (()=>nullable),
    "nullableAsync": (()=>nullableAsync),
    "nullish": (()=>nullish),
    "nullishAsync": (()=>nullishAsync),
    "number": (()=>number),
    "object": (()=>object),
    "objectAsync": (()=>objectAsync),
    "objectWithRest": (()=>objectWithRest),
    "objectWithRestAsync": (()=>objectWithRestAsync),
    "octal": (()=>octal),
    "omit": (()=>omit),
    "optional": (()=>optional),
    "optionalAsync": (()=>optionalAsync),
    "parse": (()=>parse),
    "parseAsync": (()=>parseAsync),
    "parser": (()=>parser),
    "parserAsync": (()=>parserAsync),
    "partial": (()=>partial),
    "partialAsync": (()=>partialAsync),
    "pick": (()=>pick),
    "picklist": (()=>picklist),
    "pipe": (()=>pipe),
    "pipeAsync": (()=>pipeAsync),
    "readonly": (()=>readonly),
    "record": (()=>record),
    "recordAsync": (()=>recordAsync),
    "regex": (()=>regex),
    "required": (()=>required),
    "requiredAsync": (()=>requiredAsync),
    "safeInteger": (()=>safeInteger),
    "safeParse": (()=>safeParse),
    "safeParseAsync": (()=>safeParseAsync),
    "safeParser": (()=>safeParser),
    "safeParserAsync": (()=>safeParserAsync),
    "set": (()=>set),
    "setAsync": (()=>setAsync),
    "setGlobalConfig": (()=>setGlobalConfig),
    "setGlobalMessage": (()=>setGlobalMessage),
    "setSchemaMessage": (()=>setSchemaMessage),
    "setSpecificMessage": (()=>setSpecificMessage),
    "size": (()=>size),
    "some": (()=>some),
    "startsWith": (()=>startsWith),
    "strictObject": (()=>strictObject),
    "strictObjectAsync": (()=>strictObjectAsync),
    "strictTuple": (()=>strictTuple),
    "strictTupleAsync": (()=>strictTupleAsync),
    "string": (()=>string),
    "symbol": (()=>symbol),
    "toLowerCase": (()=>toLowerCase),
    "toMaxValue": (()=>toMaxValue),
    "toMinValue": (()=>toMinValue),
    "toUpperCase": (()=>toUpperCase),
    "transform": (()=>transform),
    "transformAsync": (()=>transformAsync),
    "trim": (()=>trim),
    "trimEnd": (()=>trimEnd),
    "trimStart": (()=>trimStart),
    "tuple": (()=>tuple),
    "tupleAsync": (()=>tupleAsync),
    "tupleWithRest": (()=>tupleWithRest),
    "tupleWithRestAsync": (()=>tupleWithRestAsync),
    "ulid": (()=>ulid),
    "undefined_": (()=>undefined_),
    "union": (()=>union),
    "unionAsync": (()=>unionAsync),
    "unknown": (()=>unknown),
    "unwrap": (()=>unwrap),
    "url": (()=>url),
    "uuid": (()=>uuid),
    "value": (()=>value),
    "variant": (()=>variant),
    "variantAsync": (()=>variantAsync),
    "void_": (()=>void_)
});
var BIC_REGEX = /^[A-Z]{6}(?!00)[A-Z\d]{2}(?:[A-Z\d]{3})?$/u;
var CUID2_REGEX = /^[a-z][\da-z]*$/u;
var DECIMAL_REGEX = /^\d+$/u;
var EMAIL_REGEX = /^[\w+-]+(?:\.[\w+-]+)*@[\da-z]+(?:[.-][\da-z]+)*\.[a-z]{2,}$/iu;
var EMOJI_REGEX = /^[\p{Extended_Pictographic}\p{Emoji_Component}]+$/u;
var HEXADECIMAL_REGEX = /^(?:0h|0x)?[\da-f]+$/iu;
var HEX_COLOR_REGEX = /^#(?:[\da-f]{3,4}|[\da-f]{6}|[\da-f]{8})$/iu;
var IMEI_REGEX = /^\d{15}$|^\d{2}-\d{6}-\d{6}-\d$/u;
var IPV4_REGEX = // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive
/^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$/u;
var IPV6_REGEX = /^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu;
var IP_REGEX = /^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$|^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu;
var ISO_DATE_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])$/u;
var ISO_DATE_TIME_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])T(?:0\d|1\d|2[0-3]):[0-5]\d$/u;
var ISO_TIME_REGEX = /^(?:0\d|1\d|2[0-3]):[0-5]\d$/u;
var ISO_TIME_SECOND_REGEX = /^(?:0\d|1\d|2[0-3])(?::[0-5]\d){2}$/u;
var ISO_TIMESTAMP_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])T(?:0\d|1\d|2[0-3])(?::[0-5]\d){2}(?:\.\d{1,9})?(?:Z|[+-](?:0\d|1\d|2[0-3])(?::?[0-5]\d)?)$/u;
var ISO_WEEK_REGEX = /^\d{4}-W(?:0[1-9]|[1-4]\d|5[0-3])$/u;
var MAC48_REGEX = /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$/iu;
var MAC64_REGEX = /^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu;
var MAC_REGEX = /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$|^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu;
var OCTAL_REGEX = /^(?:0o)?[0-7]+$/iu;
var ULID_REGEX = /^[\da-hjkmnp-tv-z]{26}$/iu;
var UUID_REGEX = /^[\da-f]{8}(?:-[\da-f]{4}){3}-[\da-f]{12}$/iu;
// src/storages/globalConfig/globalConfig.ts
var store;
function setGlobalConfig(config2) {
    store = {
        ...store,
        ...config2
    };
}
function getGlobalConfig(config2) {
    return {
        lang: config2?.lang ?? store?.lang,
        message: config2?.message,
        abortEarly: config2?.abortEarly ?? store?.abortEarly,
        abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly,
        skipPipe: config2?.skipPipe
    };
}
function deleteGlobalConfig() {
    store = void 0;
}
// src/storages/globalMessage/globalMessage.ts
var store2;
function setGlobalMessage(message, lang) {
    if (!store2) store2 = /* @__PURE__ */ new Map();
    store2.set(lang, message);
}
function getGlobalMessage(lang) {
    return store2?.get(lang);
}
function deleteGlobalMessage(lang) {
    store2?.delete(lang);
}
// src/storages/schemaMessage/schemaMessage.ts
var store3;
function setSchemaMessage(message, lang) {
    if (!store3) store3 = /* @__PURE__ */ new Map();
    store3.set(lang, message);
}
function getSchemaMessage(lang) {
    return store3?.get(lang);
}
function deleteSchemaMessage(lang) {
    store3?.delete(lang);
}
// src/storages/specificMessage/specificMessage.ts
var store4;
function setSpecificMessage(reference, message, lang) {
    if (!store4) store4 = /* @__PURE__ */ new Map();
    if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());
    store4.get(reference).set(lang, message);
}
function getSpecificMessage(reference, lang) {
    return store4?.get(reference)?.get(lang);
}
function deleteSpecificMessage(reference, lang) {
    store4?.get(reference)?.delete(lang);
}
// src/utils/_stringify/_stringify.ts
function _stringify(input) {
    let type = typeof input;
    if (type === "object") {
        type = (input && Object.getPrototypeOf(input)?.constructor?.name) ?? "null";
    }
    return type === "string" ? `"${input}"` : type === "number" || type === "bigint" || type === "boolean" ? `${input}` : type;
}
// src/utils/_addIssue/_addIssue.ts
function _addIssue(context, label, dataset, config2, other) {
    const input = other && "input" in other ? other.input : dataset.value;
    const expected = other?.expected ?? context.expects;
    const received = other?.received ?? _stringify(input);
    const issue = {
        kind: context.kind,
        type: context.type,
        input,
        expected,
        received,
        message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
        // @ts-expect-error
        requirement: context.requirement,
        path: other?.path,
        issues: other?.issues,
        lang: config2.lang,
        abortEarly: config2.abortEarly,
        abortPipeEarly: config2.abortPipeEarly,
        skipPipe: config2.skipPipe
    };
    const isSchema = context.kind === "schema";
    const message = // @ts-expect-error
    context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);
    if (message) {
        issue.message = typeof message === "function" ? message(issue) : message;
    }
    if (isSchema) {
        dataset.typed = false;
    }
    if (dataset.issues) {
        dataset.issues.push(issue);
    } else {
        dataset.issues = [
            issue
        ];
    }
}
// src/utils/_isAllowedObjectKey/_isAllowedObjectKey.ts
function _isAllowedObjectKey(key) {
    return key !== "__proto__" && key !== "prototype" && key !== "constructor";
}
// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts
var NON_DIGIT_REGEX = /\D/gu;
function _isLuhnAlgo(input) {
    const number2 = input.replace(NON_DIGIT_REGEX, "");
    let length2 = number2.length;
    let bit = 1;
    let sum = 0;
    while(length2){
        const value2 = +number2[--length2];
        bit ^= 1;
        sum += bit ? [
            0,
            2,
            4,
            6,
            8,
            1,
            3,
            5,
            7,
            9
        ][value2] : value2;
    }
    return sum % 10 === 0;
}
// src/utils/entriesFromList/entriesFromList.ts
function entriesFromList(list, schema) {
    const entries = {};
    for (const key of list){
        entries[key] = schema;
    }
    return entries;
}
// src/utils/getDotPath/getDotPath.ts
function getDotPath(issue) {
    if (issue.path) {
        let key = "";
        for (const item of issue.path){
            if ("key" in item && (typeof item.key === "string" || typeof item.key === "number")) {
                if (key) {
                    key += `.${item.key}`;
                } else {
                    key += item.key;
                }
            } else {
                return null;
            }
        }
        return key;
    }
    return null;
}
// src/utils/isOfKind/isOfKind.ts
function isOfKind(kind, object2) {
    return object2.kind === kind;
}
// src/utils/isOfType/isOfType.ts
function isOfType(type, object2) {
    return object2.type === type;
}
// src/utils/isValiError/isValiError.ts
function isValiError(error) {
    return error instanceof ValiError;
}
// src/utils/ValiError/ValiError.ts
var ValiError = class extends Error {
    /**
   * The error issues.
   */ issues;
    /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */ constructor(issues){
        super(issues[0].message);
        this.name = "ValiError";
        this.issues = issues;
    }
};
// src/actions/bic/bic.ts
function bic(message) {
    return {
        kind: "validation",
        type: "bic",
        reference: bic,
        async: false,
        expects: null,
        requirement: BIC_REGEX,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "BIC", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/bytes/bytes.ts
function bytes(requirement, message) {
    return {
        kind: "validation",
        type: "bytes",
        reference: bytes,
        async: false,
        expects: `${requirement}`,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed) {
                const length2 = new TextEncoder().encode(dataset.value).length;
                if (length2 !== this.requirement) {
                    _addIssue(this, "bytes", dataset, config2, {
                        received: `${length2}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/brand/brand.ts
function brand(name) {
    return {
        kind: "transformation",
        type: "brand",
        reference: brand,
        async: false,
        name,
        _run (dataset) {
            return dataset;
        }
    };
}
// src/actions/check/check.ts
function check(requirement, message) {
    return {
        kind: "validation",
        type: "check",
        reference: check,
        async: false,
        expects: null,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement(dataset.value)) {
                _addIssue(this, "input", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/check/checkAsync.ts
function checkAsync(requirement, message) {
    return {
        kind: "validation",
        type: "check",
        reference: checkAsync,
        async: true,
        expects: null,
        requirement,
        message,
        async _run (dataset, config2) {
            if (dataset.typed && !await this.requirement(dataset.value)) {
                _addIssue(this, "input", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/creditCard/creditCard.ts
var CREDIT_CARD_REGEX = /^(?:\d{14,19}|\d{4}(?: \d{3,6}){2,4}|\d{4}(?:-\d{3,6}){2,4})$/u;
var SANITIZE_REGEX = /[- ]/gu;
var PROVIDER_REGEX_LIST = [
    // American Express
    /^3[47]\d{13}$/u,
    // Diners Club
    /^3(?:0[0-5]|[68]\d)\d{11,13}$/u,
    // Discover
    /^6(?:011|5\d{2})\d{12,15}$/u,
    // JCB
    /^(?:2131|1800|35\d{3})\d{11}$/u,
    // Mastercard
    /^5[1-5]\d{2}|(?:222\d|22[3-9]\d|2[3-6]\d{2}|27[01]\d|2720)\d{12}$/u,
    // UnionPay
    /^(?:6[27]\d{14,17}|81\d{14,17})$/u,
    // Visa
    /^4\d{12}(?:\d{3,6})?$/u
];
function creditCard(message) {
    return {
        kind: "validation",
        type: "credit_card",
        reference: creditCard,
        async: false,
        expects: null,
        requirement (input) {
            let sanitized;
            return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks
            (sanitized = input.replace(SANITIZE_REGEX, "")) && // Check if it matches a provider
            PROVIDER_REGEX_LIST.some((regex2)=>regex2.test(sanitized)) && // Check if passes luhn algorithm
            _isLuhnAlgo(sanitized);
        },
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement(dataset.value)) {
                _addIssue(this, "credit card", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/cuid2/cuid2.ts
function cuid2(message) {
    return {
        kind: "validation",
        type: "cuid2",
        reference: cuid2,
        async: false,
        expects: null,
        requirement: CUID2_REGEX,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "Cuid2", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/decimal/decimal.ts
function decimal(message) {
    return {
        kind: "validation",
        type: "decimal",
        reference: decimal,
        async: false,
        expects: null,
        requirement: DECIMAL_REGEX,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "decimal", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/email/email.ts
function email(message) {
    return {
        kind: "validation",
        type: "email",
        reference: email,
        expects: null,
        async: false,
        requirement: EMAIL_REGEX,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "email", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/emoji/emoji.ts
function emoji(message) {
    return {
        kind: "validation",
        type: "emoji",
        reference: emoji,
        async: false,
        expects: null,
        requirement: EMOJI_REGEX,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "emoji", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/empty/empty.ts
function empty(message) {
    return {
        kind: "validation",
        type: "empty",
        reference: empty,
        async: false,
        expects: "0",
        message,
        _run (dataset, config2) {
            if (dataset.typed && dataset.value.length > 0) {
                _addIssue(this, "length", dataset, config2, {
                    received: `${dataset.value.length}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/endsWith/endsWith.ts
function endsWith(requirement, message) {
    return {
        kind: "validation",
        type: "ends_with",
        reference: endsWith,
        async: false,
        expects: `"${requirement}"`,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !dataset.value.endsWith(this.requirement)) {
                _addIssue(this, "end", dataset, config2, {
                    received: `"${dataset.value.slice(-this.requirement.length)}"`
                });
            }
            return dataset;
        }
    };
}
// src/actions/every/every.ts
function every(requirement, message) {
    return {
        kind: "validation",
        type: "every",
        reference: every,
        async: false,
        expects: null,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !dataset.value.every(this.requirement)) {
                _addIssue(this, "content", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/excludes/excludes.ts
function excludes(requirement, message) {
    const received = _stringify(requirement);
    return {
        kind: "validation",
        type: "excludes",
        reference: excludes,
        async: false,
        expects: `!${received}`,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed && dataset.value.includes(this.requirement)) {
                _addIssue(this, "content", dataset, config2, {
                    received
                });
            }
            return dataset;
        }
    };
}
// src/actions/finite/finite.ts
function finite(message) {
    return {
        kind: "validation",
        type: "finite",
        reference: finite,
        async: false,
        expects: null,
        requirement: Number.isFinite,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement(dataset.value)) {
                _addIssue(this, "finite", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/hash/hash.ts
var HASH_LENGTHS = {
    md4: 32,
    md5: 32,
    sha1: 40,
    sha256: 64,
    sha384: 96,
    sha512: 128,
    ripemd128: 32,
    ripemd160: 40,
    tiger128: 32,
    tiger160: 40,
    tiger192: 48,
    crc32: 8,
    crc32b: 8,
    adler32: 8
};
function hash(types, message) {
    return {
        kind: "validation",
        type: "hash",
        reference: hash,
        expects: null,
        async: false,
        requirement: RegExp(types.map((type)=>`^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join("|"), "iu"),
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "hash", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/hexadecimal/hexadecimal.ts
function hexadecimal(message) {
    return {
        kind: "validation",
        type: "hexadecimal",
        reference: hexadecimal,
        async: false,
        expects: null,
        requirement: HEXADECIMAL_REGEX,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "hexadecimal", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/hexColor/hexColor.ts
function hexColor(message) {
    return {
        kind: "validation",
        type: "hex_color",
        reference: hexColor,
        async: false,
        expects: null,
        requirement: HEX_COLOR_REGEX,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "hex color", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/imei/imei.ts
function imei(message) {
    return {
        kind: "validation",
        type: "imei",
        reference: imei,
        async: false,
        expects: null,
        requirement (input) {
            return IMEI_REGEX.test(input) && _isLuhnAlgo(input);
        },
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement(dataset.value)) {
                _addIssue(this, "IMEI", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/includes/includes.ts
function includes(requirement, message) {
    const expects = _stringify(requirement);
    return {
        kind: "validation",
        type: "includes",
        reference: includes,
        async: false,
        expects,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !dataset.value.includes(this.requirement)) {
                _addIssue(this, "content", dataset, config2, {
                    received: `!${expects}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/integer/integer.ts
function integer(message) {
    return {
        kind: "validation",
        type: "integer",
        reference: integer,
        async: false,
        expects: null,
        requirement: Number.isInteger,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement(dataset.value)) {
                _addIssue(this, "integer", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/ip/ip.ts
function ip(message) {
    return {
        kind: "validation",
        type: "ip",
        reference: ip,
        async: false,
        expects: null,
        requirement: IP_REGEX,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "IP", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/ipv4/ipv4.ts
function ipv4(message) {
    return {
        kind: "validation",
        type: "ipv4",
        reference: ipv4,
        async: false,
        expects: null,
        requirement: IPV4_REGEX,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "IPv4", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/ipv6/ipv6.ts
function ipv6(message) {
    return {
        kind: "validation",
        type: "ipv6",
        reference: ipv6,
        async: false,
        expects: null,
        requirement: IPV6_REGEX,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "IPv6", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/isoDate/isoDate.ts
function isoDate(message) {
    return {
        kind: "validation",
        type: "iso_date",
        reference: isoDate,
        async: false,
        expects: null,
        requirement: ISO_DATE_REGEX,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "date", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/isoDateTime/isoDateTime.ts
function isoDateTime(message) {
    return {
        kind: "validation",
        type: "iso_date_time",
        reference: isoDateTime,
        async: false,
        expects: null,
        requirement: ISO_DATE_TIME_REGEX,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "date-time", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/isoTime/isoTime.ts
function isoTime(message) {
    return {
        kind: "validation",
        type: "iso_time",
        reference: isoTime,
        async: false,
        expects: null,
        requirement: ISO_TIME_REGEX,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "time", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/isoTimeSecond/isoTimeSecond.ts
function isoTimeSecond(message) {
    return {
        kind: "validation",
        type: "iso_time_second",
        reference: isoTimeSecond,
        async: false,
        expects: null,
        requirement: ISO_TIME_SECOND_REGEX,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "time-second", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/isoTimestamp/isoTimestamp.ts
function isoTimestamp(message) {
    return {
        kind: "validation",
        type: "iso_timestamp",
        reference: isoTimestamp,
        async: false,
        expects: null,
        requirement: ISO_TIMESTAMP_REGEX,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "timestamp", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/isoWeek/isoWeek.ts
function isoWeek(message) {
    return {
        kind: "validation",
        type: "iso_week",
        reference: isoWeek,
        async: false,
        expects: null,
        requirement: ISO_WEEK_REGEX,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "week", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/length/length.ts
function length(requirement, message) {
    return {
        kind: "validation",
        type: "length",
        reference: length,
        async: false,
        expects: `${requirement}`,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed && dataset.value.length !== this.requirement) {
                _addIssue(this, "length", dataset, config2, {
                    received: `${dataset.value.length}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/mac/mac.ts
function mac(message) {
    return {
        kind: "validation",
        type: "mac",
        reference: mac,
        async: false,
        expects: null,
        requirement: MAC_REGEX,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "MAC", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/mac48/mac48.ts
function mac48(message) {
    return {
        kind: "validation",
        type: "mac48",
        reference: mac48,
        async: false,
        expects: null,
        requirement: MAC48_REGEX,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "48-bit MAC", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/mac64/mac64.ts
function mac64(message) {
    return {
        kind: "validation",
        type: "mac64",
        reference: mac64,
        async: false,
        expects: null,
        requirement: MAC64_REGEX,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "64-bit MAC", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/maxBytes/maxBytes.ts
function maxBytes(requirement, message) {
    return {
        kind: "validation",
        type: "max_bytes",
        reference: maxBytes,
        async: false,
        expects: `<=${requirement}`,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed) {
                const length2 = new TextEncoder().encode(dataset.value).length;
                if (length2 > this.requirement) {
                    _addIssue(this, "bytes", dataset, config2, {
                        received: `${length2}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/maxLength/maxLength.ts
function maxLength(requirement, message) {
    return {
        kind: "validation",
        type: "max_length",
        reference: maxLength,
        async: false,
        expects: `<=${requirement}`,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed && dataset.value.length > this.requirement) {
                _addIssue(this, "length", dataset, config2, {
                    received: `${dataset.value.length}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/maxSize/maxSize.ts
function maxSize(requirement, message) {
    return {
        kind: "validation",
        type: "max_size",
        reference: maxSize,
        async: false,
        expects: `<=${requirement}`,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed && dataset.value.size > this.requirement) {
                _addIssue(this, "size", dataset, config2, {
                    received: `${dataset.value.size}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/maxValue/maxValue.ts
function maxValue(requirement, message) {
    return {
        kind: "validation",
        type: "max_value",
        reference: maxValue,
        async: false,
        expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed && dataset.value > this.requirement) {
                _addIssue(this, "value", dataset, config2, {
                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                });
            }
            return dataset;
        }
    };
}
// src/actions/mimeType/mimeType.ts
function mimeType(requirement, message) {
    return {
        kind: "validation",
        type: "mime_type",
        reference: mimeType,
        async: false,
        expects: requirement.map((option)=>`"${option}"`).join(" | ") || "never",
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.includes(dataset.value.type)) {
                _addIssue(this, "MIME type", dataset, config2, {
                    received: `"${dataset.value.type}"`
                });
            }
            return dataset;
        }
    };
}
// src/actions/minBytes/minBytes.ts
function minBytes(requirement, message) {
    return {
        kind: "validation",
        type: "min_bytes",
        reference: minBytes,
        async: false,
        expects: `>=${requirement}`,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed) {
                const length2 = new TextEncoder().encode(dataset.value).length;
                if (length2 < this.requirement) {
                    _addIssue(this, "bytes", dataset, config2, {
                        received: `${length2}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/minLength/minLength.ts
function minLength(requirement, message) {
    return {
        kind: "validation",
        type: "min_length",
        reference: minLength,
        async: false,
        expects: `>=${requirement}`,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed && dataset.value.length < this.requirement) {
                _addIssue(this, "length", dataset, config2, {
                    received: `${dataset.value.length}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/minSize/minSize.ts
function minSize(requirement, message) {
    return {
        kind: "validation",
        type: "min_size",
        reference: minSize,
        async: false,
        expects: `>=${requirement}`,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed && dataset.value.size < this.requirement) {
                _addIssue(this, "size", dataset, config2, {
                    received: `${dataset.value.size}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/minValue/minValue.ts
function minValue(requirement, message) {
    return {
        kind: "validation",
        type: "min_value",
        reference: minValue,
        async: false,
        expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed && dataset.value < this.requirement) {
                _addIssue(this, "value", dataset, config2, {
                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                });
            }
            return dataset;
        }
    };
}
// src/actions/multipleOf/multipleOf.ts
function multipleOf(requirement, message) {
    return {
        kind: "validation",
        type: "multiple_of",
        reference: multipleOf,
        async: false,
        expects: `%${requirement}`,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed && dataset.value % this.requirement !== 0) {
                _addIssue(this, "multiple", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/nonEmpty/nonEmpty.ts
function nonEmpty(message) {
    return {
        kind: "validation",
        type: "non_empty",
        reference: nonEmpty,
        async: false,
        expects: "!0",
        message,
        _run (dataset, config2) {
            if (dataset.typed && dataset.value.length === 0) {
                _addIssue(this, "length", dataset, config2, {
                    received: "0"
                });
            }
            return dataset;
        }
    };
}
// src/actions/notBytes/notBytes.ts
function notBytes(requirement, message) {
    return {
        kind: "validation",
        type: "not_bytes",
        reference: notBytes,
        async: false,
        expects: `!${requirement}`,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed) {
                const length2 = new TextEncoder().encode(dataset.value).length;
                if (length2 === this.requirement) {
                    _addIssue(this, "bytes", dataset, config2, {
                        received: `${length2}`
                    });
                }
            }
            return dataset;
        }
    };
}
// src/actions/notLength/notLength.ts
function notLength(requirement, message) {
    return {
        kind: "validation",
        type: "not_length",
        reference: notLength,
        async: false,
        expects: `!${requirement}`,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed && dataset.value.length === this.requirement) {
                _addIssue(this, "length", dataset, config2, {
                    received: `${dataset.value.length}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/notSize/notSize.ts
function notSize(requirement, message) {
    return {
        kind: "validation",
        type: "not_size",
        reference: notSize,
        async: false,
        expects: `!${requirement}`,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed && dataset.value.size === this.requirement) {
                _addIssue(this, "size", dataset, config2, {
                    received: `${dataset.value.size}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/notValue/notValue.ts
function notValue(requirement, message) {
    return {
        kind: "validation",
        type: "not_value",
        reference: notValue,
        async: false,
        expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {
                _addIssue(this, "value", dataset, config2, {
                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                });
            }
            return dataset;
        }
    };
}
// src/actions/octal/octal.ts
function octal(message) {
    return {
        kind: "validation",
        type: "octal",
        reference: octal,
        async: false,
        expects: null,
        requirement: OCTAL_REGEX,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "octal", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/readonly/readonly.ts
function readonly() {
    return {
        kind: "transformation",
        type: "readonly",
        reference: readonly,
        async: false,
        _run (dataset) {
            return dataset;
        }
    };
}
// src/actions/regex/regex.ts
function regex(requirement, message) {
    return {
        kind: "validation",
        type: "regex",
        reference: regex,
        async: false,
        expects: `${requirement}`,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "format", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/safeInteger/safeInteger.ts
function safeInteger(message) {
    return {
        kind: "validation",
        type: "safe_integer",
        reference: safeInteger,
        async: false,
        expects: null,
        requirement: Number.isSafeInteger,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement(dataset.value)) {
                _addIssue(this, "safe integer", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/size/size.ts
function size(requirement, message) {
    return {
        kind: "validation",
        type: "size",
        reference: size,
        async: false,
        expects: `${requirement}`,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed && dataset.value.size !== this.requirement) {
                _addIssue(this, "size", dataset, config2, {
                    received: `${dataset.value.size}`
                });
            }
            return dataset;
        }
    };
}
// src/actions/some/some.ts
function some(requirement, message) {
    return {
        kind: "validation",
        type: "some",
        reference: some,
        async: false,
        expects: null,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !dataset.value.some(this.requirement)) {
                _addIssue(this, "content", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/startsWith/startsWith.ts
function startsWith(requirement, message) {
    return {
        kind: "validation",
        type: "starts_with",
        reference: startsWith,
        async: false,
        expects: `"${requirement}"`,
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !dataset.value.startsWith(this.requirement)) {
                _addIssue(this, "start", dataset, config2, {
                    received: `"${dataset.value.slice(0, this.requirement.length)}"`
                });
            }
            return dataset;
        }
    };
}
// src/actions/toLowerCase/toLowerCase.ts
function toLowerCase() {
    return {
        kind: "transformation",
        type: "to_lower_case",
        reference: toLowerCase,
        async: false,
        _run (dataset) {
            dataset.value = dataset.value.toLowerCase();
            return dataset;
        }
    };
}
// src/actions/toMaxValue/toMaxValue.ts
function toMaxValue(requirement) {
    return {
        kind: "transformation",
        type: "to_max_value",
        reference: toMaxValue,
        async: false,
        requirement,
        _run (dataset) {
            dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;
            return dataset;
        }
    };
}
// src/actions/toMinValue/toMinValue.ts
function toMinValue(requirement) {
    return {
        kind: "transformation",
        type: "to_min_value",
        reference: toMinValue,
        async: false,
        requirement,
        _run (dataset) {
            dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;
            return dataset;
        }
    };
}
// src/actions/toUpperCase/toUpperCase.ts
function toUpperCase() {
    return {
        kind: "transformation",
        type: "to_upper_case",
        reference: toUpperCase,
        async: false,
        _run (dataset) {
            dataset.value = dataset.value.toUpperCase();
            return dataset;
        }
    };
}
// src/actions/transform/transform.ts
function transform(action) {
    return {
        kind: "transformation",
        type: "transform",
        reference: transform,
        async: false,
        action,
        _run (dataset) {
            dataset.value = action(dataset.value);
            return dataset;
        }
    };
}
// src/actions/transform/transformAsync.ts
function transformAsync(action) {
    return {
        kind: "transformation",
        type: "transform",
        reference: transformAsync,
        async: true,
        action,
        async _run (dataset) {
            dataset.value = await action(dataset.value);
            return dataset;
        }
    };
}
// src/actions/trim/trim.ts
function trim() {
    return {
        kind: "transformation",
        type: "trim",
        reference: trim,
        async: false,
        _run (dataset) {
            dataset.value = dataset.value.trim();
            return dataset;
        }
    };
}
// src/actions/trimEnd/trimEnd.ts
function trimEnd() {
    return {
        kind: "transformation",
        type: "trim_end",
        reference: trimEnd,
        async: false,
        _run (dataset) {
            dataset.value = dataset.value.trimEnd();
            return dataset;
        }
    };
}
// src/actions/trimStart/trimStart.ts
function trimStart() {
    return {
        kind: "transformation",
        type: "trim_start",
        reference: trimStart,
        async: false,
        _run (dataset) {
            dataset.value = dataset.value.trimStart();
            return dataset;
        }
    };
}
// src/actions/ulid/ulid.ts
function ulid(message) {
    return {
        kind: "validation",
        type: "ulid",
        reference: ulid,
        async: false,
        expects: null,
        requirement: ULID_REGEX,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "ULID", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/url/url.ts
function url(message) {
    return {
        kind: "validation",
        type: "url",
        reference: url,
        async: false,
        expects: null,
        requirement (input) {
            try {
                new URL(input);
                return true;
            } catch  {
                return false;
            }
        },
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement(dataset.value)) {
                _addIssue(this, "URL", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/uuid/uuid.ts
function uuid(message) {
    return {
        kind: "validation",
        type: "uuid",
        reference: uuid,
        async: false,
        expects: null,
        requirement: UUID_REGEX,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !this.requirement.test(dataset.value)) {
                _addIssue(this, "UUID", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/actions/value/value.ts
function value(requirement, message) {
    return {
        kind: "validation",
        type: "value",
        reference: value,
        async: false,
        expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),
        requirement,
        message,
        _run (dataset, config2) {
            if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {
                _addIssue(this, "value", dataset, config2, {
                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                });
            }
            return dataset;
        }
    };
}
// src/methods/config/config.ts
function config(schema, config2) {
    return {
        ...schema,
        _run (dataset, config_) {
            return schema._run(dataset, {
                ...config_,
                ...config2
            });
        }
    };
}
// src/methods/getFallback/getFallback.ts
function getFallback(schema, dataset, config2) {
    return typeof schema.fallback === "function" ? // @ts-expect-error
    schema.fallback(dataset, config2) : // @ts-expect-error
    schema.fallback;
}
// src/methods/fallback/fallback.ts
function fallback(schema, fallback2) {
    return {
        ...schema,
        fallback: fallback2,
        _run (dataset, config2) {
            schema._run(dataset, config2);
            return dataset.issues ? {
                typed: true,
                value: getFallback(this, dataset, config2)
            } : dataset;
        }
    };
}
// src/methods/fallback/fallbackAsync.ts
function fallbackAsync(schema, fallback2) {
    return {
        ...schema,
        fallback: fallback2,
        async: true,
        async _run (dataset, config2) {
            schema._run(dataset, config2);
            return dataset.issues ? // @ts-expect-error
            {
                typed: true,
                value: await getFallback(this, dataset, config2)
            } : dataset;
        }
    };
}
// src/methods/flatten/flatten.ts
function flatten(issues) {
    const flatErrors = {};
    for (const issue of issues){
        if (issue.path) {
            const dotPath = getDotPath(issue);
            if (dotPath) {
                if (!flatErrors.nested) {
                    flatErrors.nested = {};
                }
                if (flatErrors.nested[dotPath]) {
                    flatErrors.nested[dotPath].push(issue.message);
                } else {
                    flatErrors.nested[dotPath] = [
                        issue.message
                    ];
                }
            } else {
                if (flatErrors.other) {
                    flatErrors.other.push(issue.message);
                } else {
                    flatErrors.other = [
                        issue.message
                    ];
                }
            }
        } else {
            if (flatErrors.root) {
                flatErrors.root.push(issue.message);
            } else {
                flatErrors.root = [
                    issue.message
                ];
            }
        }
    }
    return flatErrors;
}
// src/methods/forward/forward.ts
function forward(action, pathKeys) {
    return {
        ...action,
        _run (dataset, config2) {
            const prevIssues = dataset.issues && [
                ...dataset.issues
            ];
            action._run(dataset, config2);
            if (dataset.issues) {
                for (const issue of dataset.issues){
                    if (!prevIssues?.includes(issue)) {
                        let pathInput = dataset.value;
                        for (const key of pathKeys){
                            const pathValue = pathInput[key];
                            const pathItem = {
                                type: "unknown",
                                origin: "value",
                                input: pathInput,
                                key,
                                value: pathValue
                            };
                            if (issue.path) {
                                issue.path.push(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            if (!pathValue) {
                                break;
                            }
                            pathInput = pathValue;
                        }
                    }
                }
            }
            return dataset;
        }
    };
}
// src/methods/forward/forwardAsync.ts
function forwardAsync(action, pathKeys) {
    return {
        ...action,
        async: true,
        async _run (dataset, config2) {
            const prevIssues = dataset.issues && [
                ...dataset.issues
            ];
            await action._run(dataset, config2);
            if (dataset.issues) {
                for (const issue of dataset.issues){
                    if (!prevIssues?.includes(issue)) {
                        let pathInput = dataset.value;
                        for (const key of pathKeys){
                            const pathValue = pathInput[key];
                            const pathItem = {
                                type: "unknown",
                                origin: "value",
                                input: pathInput,
                                key,
                                value: pathValue
                            };
                            if (issue.path) {
                                issue.path.push(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            if (!pathValue) {
                                break;
                            }
                            pathInput = pathValue;
                        }
                    }
                }
            }
            return dataset;
        }
    };
}
// src/methods/getDefault/getDefault.ts
function getDefault(schema, dataset, config2) {
    return typeof schema.default === "function" ? // @ts-expect-error
    schema.default(dataset, config2) : // @ts-expect-error
    schema.default;
}
// src/methods/getDefaults/getDefaults.ts
function getDefaults(schema) {
    if ("entries" in schema) {
        const object2 = {};
        for(const key in schema.entries){
            object2[key] = getDefaults(schema.entries[key]);
        }
        return object2;
    }
    if ("items" in schema) {
        return schema.items.map(getDefaults);
    }
    return getDefault(schema);
}
// src/methods/getDefaults/getDefaultsAsync.ts
async function getDefaultsAsync(schema) {
    if ("entries" in schema) {
        return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value2])=>[
                key,
                await getDefaultsAsync(value2)
            ])));
    }
    if ("items" in schema) {
        return Promise.all(schema.items.map(getDefaultsAsync));
    }
    return getDefault(schema);
}
// src/methods/getFallbacks/getFallbacks.ts
function getFallbacks(schema) {
    if ("entries" in schema) {
        const object2 = {};
        for(const key in schema.entries){
            object2[key] = getFallbacks(schema.entries[key]);
        }
        return object2;
    }
    if ("items" in schema) {
        return schema.items.map(getFallbacks);
    }
    return getFallback(schema);
}
// src/methods/getFallbacks/getFallbacksAsync.ts
async function getFallbacksAsync(schema) {
    if ("entries" in schema) {
        return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value2])=>[
                key,
                await getFallbacksAsync(value2)
            ])));
    }
    if ("items" in schema) {
        return Promise.all(schema.items.map(getFallbacksAsync));
    }
    return getFallback(schema);
}
// src/methods/is/is.ts
function is(schema, input) {
    return !schema._run({
        typed: false,
        value: input
    }, {
        abortEarly: true
    }).issues;
}
// src/schemas/any/any.ts
function any() {
    return {
        kind: "schema",
        type: "any",
        reference: any,
        expects: "any",
        async: false,
        _run (dataset) {
            dataset.typed = true;
            return dataset;
        }
    };
}
// src/schemas/array/array.ts
function array(item, message) {
    return {
        kind: "schema",
        type: "array",
        reference: array,
        expects: "Array",
        async: false,
        item,
        message,
        _run (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                for(let key = 0; key < input.length; key++){
                    const value2 = input[key];
                    const itemDataset = this.item._run({
                        typed: false,
                        value: value2
                    }, config2);
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/array/arrayAsync.ts
function arrayAsync(item, message) {
    return {
        kind: "schema",
        type: "array",
        reference: arrayAsync,
        expects: "Array",
        async: true,
        item,
        message,
        async _run (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                const itemDatasets = await Promise.all(input.map((value2)=>this.item._run({
                        typed: false,
                        value: value2
                    }, config2)));
                for(let key = 0; key < itemDatasets.length; key++){
                    const itemDataset = itemDatasets[key];
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "array",
                            origin: "value",
                            input,
                            key,
                            value: input[key]
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/bigint/bigint.ts
function bigint(message) {
    return {
        kind: "schema",
        type: "bigint",
        reference: bigint,
        expects: "bigint",
        async: false,
        message,
        _run (dataset, config2) {
            if (typeof dataset.value === "bigint") {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/blob/blob.ts
function blob(message) {
    return {
        kind: "schema",
        type: "blob",
        reference: blob,
        expects: "Blob",
        async: false,
        message,
        _run (dataset, config2) {
            if (dataset.value instanceof Blob) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/boolean/boolean.ts
function boolean(message) {
    return {
        kind: "schema",
        type: "boolean",
        reference: boolean,
        expects: "boolean",
        async: false,
        message,
        _run (dataset, config2) {
            if (typeof dataset.value === "boolean") {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/custom/custom.ts
function custom(check2, message) {
    return {
        kind: "schema",
        type: "custom",
        reference: custom,
        expects: "unknown",
        async: false,
        check: check2,
        message,
        _run (dataset, config2) {
            if (this.check(dataset.value)) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/custom/customAsync.ts
function customAsync(check2, message) {
    return {
        kind: "schema",
        type: "custom",
        reference: customAsync,
        expects: "unknown",
        async: true,
        check: check2,
        message,
        async _run (dataset, config2) {
            if (await this.check(dataset.value)) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/date/date.ts
function date(message) {
    return {
        kind: "schema",
        type: "date",
        reference: date,
        expects: "Date",
        async: false,
        message,
        _run (dataset, config2) {
            if (dataset.value instanceof Date && !isNaN(dataset.value.getTime())) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/enum/enum.ts
function enum_(enum__, message) {
    const options = Object.entries(enum__).filter(([key])=>isNaN(+key)).map(([, value2])=>value2);
    return {
        kind: "schema",
        type: "enum",
        reference: enum_,
        expects: options.map(_stringify).join(" | ") || "never",
        async: false,
        enum: enum__,
        options,
        message,
        _run (dataset, config2) {
            if (this.options.includes(dataset.value)) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/instance/instance.ts
function instance(class_, message) {
    return {
        kind: "schema",
        type: "instance",
        reference: instance,
        expects: class_.name,
        async: false,
        class: class_,
        message,
        _run (dataset, config2) {
            if (dataset.value instanceof this.class) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/intersect/utils/_merge/_merge.ts
function _merge(value1, value2) {
    if (typeof value1 === typeof value2) {
        if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {
            return {
                value: value1
            };
        }
        if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {
            for(const key in value2){
                if (key in value1) {
                    const dataset = _merge(value1[key], value2[key]);
                    if (dataset.issue) {
                        return dataset;
                    }
                    value1[key] = dataset.value;
                } else {
                    value1[key] = value2[key];
                }
            }
            return {
                value: value1
            };
        }
        if (Array.isArray(value1) && Array.isArray(value2)) {
            if (value1.length === value2.length) {
                for(let index = 0; index < value1.length; index++){
                    const dataset = _merge(value1[index], value2[index]);
                    if (dataset.issue) {
                        return dataset;
                    }
                    value1[index] = dataset.value;
                }
                return {
                    value: value1
                };
            }
        }
    }
    return {
        issue: true
    };
}
// src/schemas/intersect/intersect.ts
function intersect(options, message) {
    return {
        kind: "schema",
        type: "intersect",
        reference: intersect,
        expects: [
            ...new Set(options.map((option)=>option.expects))
        ].join(" & ") || "never",
        async: false,
        options,
        message,
        _run (dataset, config2) {
            if (this.options.length) {
                const input = dataset.value;
                let outputs;
                dataset.typed = true;
                for (const schema of this.options){
                    const optionDataset = schema._run({
                        typed: false,
                        value: input
                    }, config2);
                    if (optionDataset.issues) {
                        if (dataset.issues) {
                            dataset.issues.push(...optionDataset.issues);
                        } else {
                            dataset.issues = optionDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!optionDataset.typed) {
                        dataset.typed = false;
                    }
                    if (dataset.typed) {
                        if (outputs) {
                            outputs.push(optionDataset.value);
                        } else {
                            outputs = [
                                optionDataset.value
                            ];
                        }
                    }
                }
                if (dataset.typed) {
                    dataset.value = outputs[0];
                    for(let index = 1; index < outputs.length; index++){
                        const mergeDataset = _merge(dataset.value, outputs[index]);
                        if (mergeDataset.issue) {
                            _addIssue(this, "type", dataset, config2, {
                                received: "unknown"
                            });
                            break;
                        }
                        dataset.value = mergeDataset.value;
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/intersect/intersectAsync.ts
function intersectAsync(options, message) {
    return {
        kind: "schema",
        type: "intersect",
        reference: intersectAsync,
        expects: [
            ...new Set(options.map((option)=>option.expects))
        ].join(" & ") || "never",
        async: true,
        options,
        message,
        async _run (dataset, config2) {
            if (this.options.length) {
                const input = dataset.value;
                let outputs;
                dataset.typed = true;
                const optionDatasets = await Promise.all(this.options.map((schema)=>schema._run({
                        typed: false,
                        value: input
                    }, config2)));
                for (const optionDataset of optionDatasets){
                    if (optionDataset.issues) {
                        if (dataset.issues) {
                            dataset.issues.push(...optionDataset.issues);
                        } else {
                            dataset.issues = optionDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!optionDataset.typed) {
                        dataset.typed = false;
                    }
                    if (dataset.typed) {
                        if (outputs) {
                            outputs.push(optionDataset.value);
                        } else {
                            outputs = [
                                optionDataset.value
                            ];
                        }
                    }
                }
                if (dataset.typed) {
                    dataset.value = outputs[0];
                    for(let index = 1; index < outputs.length; index++){
                        const mergeDataset = _merge(dataset.value, outputs[index]);
                        if (mergeDataset.issue) {
                            _addIssue(this, "type", dataset, config2, {
                                received: "unknown"
                            });
                            break;
                        }
                        dataset.value = mergeDataset.value;
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/lazy/lazy.ts
function lazy(getter) {
    return {
        kind: "schema",
        type: "lazy",
        reference: lazy,
        expects: "unknown",
        async: false,
        getter,
        _run (dataset, config2) {
            return this.getter(dataset.value)._run(dataset, config2);
        }
    };
}
// src/schemas/lazy/lazyAsync.ts
function lazyAsync(getter) {
    return {
        kind: "schema",
        type: "lazy",
        reference: lazyAsync,
        expects: "unknown",
        async: true,
        getter,
        async _run (dataset, config2) {
            return (await this.getter(dataset.value))._run(dataset, config2);
        }
    };
}
// src/schemas/literal/literal.ts
function literal(literal_, message) {
    return {
        kind: "schema",
        type: "literal",
        reference: literal,
        expects: _stringify(literal_),
        async: false,
        literal: literal_,
        message,
        _run (dataset, config2) {
            if (dataset.value === this.literal) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/looseObject/looseObject.ts
function looseObject(entries, message) {
    return {
        kind: "schema",
        type: "loose_object",
        reference: looseObject,
        expects: "Object",
        async: false,
        entries,
        message,
        _run (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                for(const key in this.entries){
                    const value2 = input[key];
                    const valueDataset = this.entries[key]._run({
                        typed: false,
                        value: value2
                    }, config2);
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "object",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = valueDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!valueDataset.typed) {
                        dataset.typed = false;
                    }
                    if (valueDataset.value !== void 0 || key in input) {
                        dataset.value[key] = valueDataset.value;
                    }
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(const key in input){
                        if (_isAllowedObjectKey(key) && !(key in this.entries)) {
                            dataset.value[key] = input[key];
                        }
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/looseObject/looseObjectAsync.ts
function looseObjectAsync(entries, message) {
    return {
        kind: "schema",
        type: "loose_object",
        reference: looseObjectAsync,
        expects: "Object",
        async: true,
        entries,
        message,
        async _run (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, schema])=>{
                    const value2 = input[key];
                    return [
                        key,
                        value2,
                        await schema._run({
                            typed: false,
                            value: value2
                        }, config2)
                    ];
                }));
                for (const [key, value2, valueDataset] of valueDatasets){
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "object",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = valueDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!valueDataset.typed) {
                        dataset.typed = false;
                    }
                    if (valueDataset.value !== void 0 || key in input) {
                        dataset.value[key] = valueDataset.value;
                    }
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(const key in input){
                        if (_isAllowedObjectKey(key) && !(key in this.entries)) {
                            dataset.value[key] = input[key];
                        }
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/looseTuple/looseTuple.ts
function looseTuple(items, message) {
    return {
        kind: "schema",
        type: "loose_tuple",
        reference: looseTuple,
        expects: "Array",
        async: false,
        items,
        message,
        _run (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                for(let key = 0; key < items.length; key++){
                    const value2 = input[key];
                    const itemDataset = this.items[key]._run({
                        typed: false,
                        value: value2
                    }, config2);
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "tuple",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(let key = items.length; key < input.length; key++){
                        dataset.value.push(input[key]);
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/looseTuple/looseTupleAsync.ts
function looseTupleAsync(items, message) {
    return {
        kind: "schema",
        type: "loose_tuple",
        reference: looseTupleAsync,
        expects: "Array",
        async: true,
        items,
        message,
        async _run (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                const itemDatasets = await Promise.all(items.map(async (item, key)=>{
                    const value2 = input[key];
                    return [
                        key,
                        value2,
                        await item._run({
                            typed: false,
                            value: value2
                        }, config2)
                    ];
                }));
                for (const [key, value2, itemDataset] of itemDatasets){
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "tuple",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(let key = items.length; key < input.length; key++){
                        dataset.value.push(input[key]);
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/map/map.ts
function map(key, value2, message) {
    return {
        kind: "schema",
        type: "map",
        reference: map,
        expects: "Map",
        async: false,
        key,
        value: value2,
        message,
        _run (dataset, config2) {
            const input = dataset.value;
            if (input instanceof Map) {
                dataset.typed = true;
                dataset.value = /* @__PURE__ */ new Map();
                for (const [inputKey, inputValue] of input){
                    const keyDataset = this.key._run({
                        typed: false,
                        value: inputKey
                    }, config2);
                    if (keyDataset.issues) {
                        const pathItem = {
                            type: "map",
                            origin: "key",
                            input,
                            key: inputKey,
                            value: inputValue
                        };
                        for (const issue of keyDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = keyDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    const valueDataset = this.value._run({
                        typed: false,
                        value: inputValue
                    }, config2);
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "map",
                            origin: "value",
                            input,
                            key: inputKey,
                            value: inputValue
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = valueDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!keyDataset.typed || !valueDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.set(keyDataset.value, valueDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/map/mapAsync.ts
function mapAsync(key, value2, message) {
    return {
        kind: "schema",
        type: "map",
        reference: mapAsync,
        expects: "Map",
        async: true,
        key,
        value: value2,
        message,
        async _run (dataset, config2) {
            const input = dataset.value;
            if (input instanceof Map) {
                dataset.typed = true;
                dataset.value = /* @__PURE__ */ new Map();
                const datasets = await Promise.all([
                    ...input
                ].map(([inputKey, inputValue])=>Promise.all([
                        inputKey,
                        inputValue,
                        this.key._run({
                            typed: false,
                            value: inputKey
                        }, config2),
                        this.value._run({
                            typed: false,
                            value: inputValue
                        }, config2)
                    ])));
                for (const [inputKey, inputValue, keyDataset, valueDataset] of datasets){
                    if (keyDataset.issues) {
                        const pathItem = {
                            type: "map",
                            origin: "key",
                            input,
                            key: inputKey,
                            value: inputValue
                        };
                        for (const issue of keyDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = keyDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "map",
                            origin: "value",
                            input,
                            key: inputKey,
                            value: inputValue
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = valueDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!keyDataset.typed || !valueDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.set(keyDataset.value, valueDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/nan/nan.ts
function nan(message) {
    return {
        kind: "schema",
        type: "nan",
        reference: nan,
        expects: "NaN",
        async: false,
        message,
        _run (dataset, config2) {
            if (Number.isNaN(dataset.value)) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/never/never.ts
function never(message) {
    return {
        kind: "schema",
        type: "never",
        reference: never,
        expects: "never",
        async: false,
        message,
        _run (dataset, config2) {
            _addIssue(this, "type", dataset, config2);
            return dataset;
        }
    };
}
// src/schemas/nonNullable/nonNullable.ts
function nonNullable(wrapped, message) {
    return {
        kind: "schema",
        type: "non_nullable",
        reference: nonNullable,
        expects: "!null",
        async: false,
        wrapped,
        message,
        _run (dataset, config2) {
            if (dataset.value === null) {
                _addIssue(this, "type", dataset, config2);
                return dataset;
            }
            return this.wrapped._run(dataset, config2);
        }
    };
}
// src/schemas/nonNullable/nonNullableAsync.ts
function nonNullableAsync(wrapped, message) {
    return {
        kind: "schema",
        type: "non_nullable",
        reference: nonNullableAsync,
        expects: "!null",
        async: true,
        wrapped,
        message,
        async _run (dataset, config2) {
            if (dataset.value === null) {
                _addIssue(this, "type", dataset, config2);
                return dataset;
            }
            return this.wrapped._run(dataset, config2);
        }
    };
}
// src/schemas/nonNullish/nonNullish.ts
function nonNullish(wrapped, message) {
    return {
        kind: "schema",
        type: "non_nullish",
        reference: nonNullish,
        expects: "!null & !undefined",
        async: false,
        wrapped,
        message,
        _run (dataset, config2) {
            if (dataset.value === null || dataset.value === void 0) {
                _addIssue(this, "type", dataset, config2);
                return dataset;
            }
            return this.wrapped._run(dataset, config2);
        }
    };
}
// src/schemas/nonNullish/nonNullishAsync.ts
function nonNullishAsync(wrapped, message) {
    return {
        kind: "schema",
        type: "non_nullish",
        reference: nonNullishAsync,
        expects: "!null & !undefined",
        async: true,
        wrapped,
        message,
        async _run (dataset, config2) {
            if (dataset.value === null || dataset.value === void 0) {
                _addIssue(this, "type", dataset, config2);
                return dataset;
            }
            return this.wrapped._run(dataset, config2);
        }
    };
}
// src/schemas/nonOptional/nonOptional.ts
function nonOptional(wrapped, message) {
    return {
        kind: "schema",
        type: "non_optional",
        reference: nonOptional,
        expects: "!undefined",
        async: false,
        wrapped,
        message,
        _run (dataset, config2) {
            if (dataset.value === void 0) {
                _addIssue(this, "type", dataset, config2);
                return dataset;
            }
            return this.wrapped._run(dataset, config2);
        }
    };
}
// src/schemas/nonOptional/nonOptionalAsync.ts
function nonOptionalAsync(wrapped, message) {
    return {
        kind: "schema",
        type: "non_optional",
        reference: nonOptionalAsync,
        expects: "!undefined",
        async: true,
        wrapped,
        message,
        async _run (dataset, config2) {
            if (dataset.value === void 0) {
                _addIssue(this, "type", dataset, config2);
                return dataset;
            }
            return this.wrapped._run(dataset, config2);
        }
    };
}
// src/schemas/null/null.ts
function null_(message) {
    return {
        kind: "schema",
        type: "null",
        reference: null_,
        expects: "null",
        async: false,
        message,
        _run (dataset, config2) {
            if (dataset.value === null) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/nullable/nullable.ts
function nullable(wrapped, ...args) {
    const schema = {
        kind: "schema",
        type: "nullable",
        reference: nullable,
        expects: `${wrapped.expects} | null`,
        async: false,
        wrapped,
        _run (dataset, config2) {
            if (dataset.value === null) {
                if ("default" in this) {
                    dataset.value = getDefault(this, dataset, config2);
                }
                if (dataset.value === null) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped._run(dataset, config2);
        }
    };
    if (0 in args) {
        schema.default = args[0];
    }
    return schema;
}
// src/schemas/nullable/nullableAsync.ts
function nullableAsync(wrapped, ...args) {
    const schema = {
        kind: "schema",
        type: "nullable",
        reference: nullableAsync,
        expects: `${wrapped.expects} | null`,
        async: true,
        wrapped,
        async _run (dataset, config2) {
            if (dataset.value === null) {
                if ("default" in this) {
                    dataset.value = await getDefault(this, dataset, config2);
                }
                if (dataset.value === null) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped._run(dataset, config2);
        }
    };
    if (0 in args) {
        schema.default = args[0];
    }
    return schema;
}
// src/schemas/nullish/nullish.ts
function nullish(wrapped, ...args) {
    const schema = {
        kind: "schema",
        type: "nullish",
        reference: nullish,
        expects: `${wrapped.expects} | null | undefined`,
        async: false,
        wrapped,
        _run (dataset, config2) {
            if (dataset.value === null || dataset.value === void 0) {
                if ("default" in this) {
                    dataset.value = getDefault(this, dataset, config2);
                }
                if (dataset.value === null || dataset.value === void 0) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped._run(dataset, config2);
        }
    };
    if (0 in args) {
        schema.default = args[0];
    }
    return schema;
}
// src/schemas/nullish/nullishAsync.ts
function nullishAsync(wrapped, ...args) {
    const schema = {
        kind: "schema",
        type: "nullish",
        reference: nullishAsync,
        expects: `${wrapped.expects} | null | undefined`,
        async: true,
        wrapped,
        async _run (dataset, config2) {
            if (dataset.value === null || dataset.value === void 0) {
                if ("default" in this) {
                    dataset.value = await getDefault(this, dataset, config2);
                }
                if (dataset.value === null || dataset.value === void 0) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped._run(dataset, config2);
        }
    };
    if (0 in args) {
        schema.default = args[0];
    }
    return schema;
}
// src/schemas/number/number.ts
function number(message) {
    return {
        kind: "schema",
        type: "number",
        reference: number,
        expects: "number",
        async: false,
        message,
        _run (dataset, config2) {
            if (typeof dataset.value === "number" && !isNaN(dataset.value)) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/object/object.ts
function object(entries, message) {
    return {
        kind: "schema",
        type: "object",
        reference: object,
        expects: "Object",
        async: false,
        entries,
        message,
        _run (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                for(const key in this.entries){
                    const value2 = input[key];
                    const valueDataset = this.entries[key]._run({
                        typed: false,
                        value: value2
                    }, config2);
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "object",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = valueDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!valueDataset.typed) {
                        dataset.typed = false;
                    }
                    if (valueDataset.value !== void 0 || key in input) {
                        dataset.value[key] = valueDataset.value;
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/object/objectAsync.ts
function objectAsync(entries, message) {
    return {
        kind: "schema",
        type: "object",
        reference: objectAsync,
        expects: "Object",
        async: true,
        entries,
        message,
        async _run (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, schema])=>{
                    const value2 = input[key];
                    return [
                        key,
                        value2,
                        await schema._run({
                            typed: false,
                            value: value2
                        }, config2)
                    ];
                }));
                for (const [key, value2, valueDataset] of valueDatasets){
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "object",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = valueDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!valueDataset.typed) {
                        dataset.typed = false;
                    }
                    if (valueDataset.value !== void 0 || key in input) {
                        dataset.value[key] = valueDataset.value;
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/objectWithRest/objectWithRest.ts
function objectWithRest(entries, rest, message) {
    return {
        kind: "schema",
        type: "object_with_rest",
        reference: objectWithRest,
        expects: "Object",
        async: false,
        entries,
        rest,
        message,
        _run (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                for(const key in this.entries){
                    const value2 = input[key];
                    const valueDataset = this.entries[key]._run({
                        typed: false,
                        value: value2
                    }, config2);
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "object",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = valueDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!valueDataset.typed) {
                        dataset.typed = false;
                    }
                    if (valueDataset.value !== void 0 || key in input) {
                        dataset.value[key] = valueDataset.value;
                    }
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(const key in input){
                        if (_isAllowedObjectKey(key) && !(key in this.entries)) {
                            const value2 = input[key];
                            const valueDataset = this.rest._run({
                                typed: false,
                                value: value2
                            }, config2);
                            if (valueDataset.issues) {
                                const pathItem = {
                                    type: "object",
                                    origin: "value",
                                    input,
                                    key,
                                    value: value2
                                };
                                for (const issue of valueDataset.issues){
                                    if (issue.path) {
                                        issue.path.unshift(pathItem);
                                    } else {
                                        issue.path = [
                                            pathItem
                                        ];
                                    }
                                    dataset.issues?.push(issue);
                                }
                                if (!dataset.issues) {
                                    dataset.issues = valueDataset.issues;
                                }
                                if (config2.abortEarly) {
                                    dataset.typed = false;
                                    break;
                                }
                            }
                            if (!valueDataset.typed) {
                                dataset.typed = false;
                            }
                            dataset.value[key] = valueDataset.value;
                        }
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/objectWithRest/objectWithRestAsync.ts
function objectWithRestAsync(entries, rest, message) {
    return {
        kind: "schema",
        type: "object_with_rest",
        reference: objectWithRestAsync,
        expects: "Object",
        async: true,
        entries,
        rest,
        message,
        async _run (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                const [normalDatasets, restDatasets] = await Promise.all([
                    // Parse schema of each normal entry
                    Promise.all(Object.entries(this.entries).map(async ([key, schema])=>{
                        const value2 = input[key];
                        return [
                            key,
                            value2,
                            await schema._run({
                                typed: false,
                                value: value2
                            }, config2)
                        ];
                    })),
                    // Parse other entries with rest schema
                    Promise.all(Object.entries(input).filter(([key])=>_isAllowedObjectKey(key) && !(key in this.entries)).map(async ([key, value2])=>[
                            key,
                            value2,
                            await this.rest._run({
                                typed: false,
                                value: value2
                            }, config2)
                        ]))
                ]);
                for (const [key, value2, valueDataset] of normalDatasets){
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "object",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = valueDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!valueDataset.typed) {
                        dataset.typed = false;
                    }
                    if (valueDataset.value !== void 0 || key in input) {
                        dataset.value[key] = valueDataset.value;
                    }
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for (const [key, value2, valueDataset] of restDatasets){
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!valueDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value[key] = valueDataset.value;
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/optional/optional.ts
function optional(wrapped, ...args) {
    const schema = {
        kind: "schema",
        type: "optional",
        reference: optional,
        expects: `${wrapped.expects} | undefined`,
        async: false,
        wrapped,
        _run (dataset, config2) {
            if (dataset.value === void 0) {
                if ("default" in this) {
                    dataset.value = getDefault(this, dataset, config2);
                }
                if (dataset.value === void 0) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped._run(dataset, config2);
        }
    };
    if (0 in args) {
        schema.default = args[0];
    }
    return schema;
}
// src/schemas/optional/optionalAsync.ts
function optionalAsync(wrapped, ...args) {
    const schema = {
        kind: "schema",
        type: "optional",
        reference: optionalAsync,
        expects: `${wrapped.expects} | undefined`,
        async: true,
        wrapped,
        async _run (dataset, config2) {
            if (dataset.value === void 0) {
                if ("default" in this) {
                    dataset.value = await getDefault(this, dataset, config2);
                }
                if (dataset.value === void 0) {
                    dataset.typed = true;
                    return dataset;
                }
            }
            return this.wrapped._run(dataset, config2);
        }
    };
    if (0 in args) {
        schema.default = args[0];
    }
    return schema;
}
// src/schemas/picklist/picklist.ts
function picklist(options, message) {
    return {
        kind: "schema",
        type: "picklist",
        reference: picklist,
        expects: options.map(_stringify).join(" | ") || "never",
        async: false,
        options,
        message,
        _run (dataset, config2) {
            if (this.options.includes(dataset.value)) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/record/record.ts
function record(key, value2, message) {
    return {
        kind: "schema",
        type: "record",
        reference: record,
        expects: "Object",
        async: false,
        key,
        value: value2,
        message,
        _run (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                for(const entryKey in input){
                    if (_isAllowedObjectKey(entryKey)) {
                        const entryValue = input[entryKey];
                        const keyDataset = this.key._run({
                            typed: false,
                            value: entryKey
                        }, config2);
                        if (keyDataset.issues) {
                            const pathItem = {
                                type: "record",
                                origin: "key",
                                input,
                                key: entryKey,
                                value: entryValue
                            };
                            for (const issue of keyDataset.issues){
                                issue.path = [
                                    pathItem
                                ];
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = keyDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        const valueDataset = this.value._run({
                            typed: false,
                            value: entryValue
                        }, config2);
                        if (valueDataset.issues) {
                            const pathItem = {
                                type: "record",
                                origin: "value",
                                input,
                                key: entryKey,
                                value: entryValue
                            };
                            for (const issue of valueDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!keyDataset.typed || !valueDataset.typed) {
                            dataset.typed = false;
                        }
                        if (keyDataset.typed) {
                            dataset.value[keyDataset.value] = valueDataset.value;
                        }
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/record/recordAsync.ts
function recordAsync(key, value2, message) {
    return {
        kind: "schema",
        type: "record",
        reference: recordAsync,
        expects: "Object",
        async: true,
        key,
        value: value2,
        message,
        async _run (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                const datasets = await Promise.all(Object.entries(input).filter(([key2])=>_isAllowedObjectKey(key2)).map(([entryKey, entryValue])=>Promise.all([
                        entryKey,
                        entryValue,
                        this.key._run({
                            typed: false,
                            value: entryKey
                        }, config2),
                        this.value._run({
                            typed: false,
                            value: entryValue
                        }, config2)
                    ])));
                for (const [entryKey, entryValue, keyDataset, valueDataset] of datasets){
                    if (keyDataset.issues) {
                        const pathItem = {
                            type: "record",
                            origin: "key",
                            input,
                            key: entryKey,
                            value: entryValue
                        };
                        for (const issue of keyDataset.issues){
                            issue.path = [
                                pathItem
                            ];
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = keyDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "record",
                            origin: "value",
                            input,
                            key: entryKey,
                            value: entryValue
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = valueDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!keyDataset.typed || !valueDataset.typed) {
                        dataset.typed = false;
                    }
                    if (keyDataset.typed) {
                        dataset.value[keyDataset.value] = valueDataset.value;
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/set/set.ts
function set(value2, message) {
    return {
        kind: "schema",
        type: "set",
        reference: set,
        expects: "Set",
        async: false,
        value: value2,
        message,
        _run (dataset, config2) {
            const input = dataset.value;
            if (input instanceof Set) {
                dataset.typed = true;
                dataset.value = /* @__PURE__ */ new Set();
                for (const inputValue of input){
                    const valueDataset = this.value._run({
                        typed: false,
                        value: inputValue
                    }, config2);
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "set",
                            origin: "value",
                            input,
                            value: inputValue
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = valueDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!valueDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.add(valueDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/set/setAsync.ts
function setAsync(value2, message) {
    return {
        kind: "schema",
        type: "set",
        reference: setAsync,
        expects: "Set",
        async: true,
        value: value2,
        message,
        async _run (dataset, config2) {
            const input = dataset.value;
            if (input instanceof Set) {
                dataset.typed = true;
                dataset.value = /* @__PURE__ */ new Set();
                const valueDatasets = await Promise.all([
                    ...input
                ].map(async (inputValue)=>[
                        inputValue,
                        await this.value._run({
                            typed: false,
                            value: inputValue
                        }, config2)
                    ]));
                for (const [inputValue, valueDataset] of valueDatasets){
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "set",
                            origin: "value",
                            input,
                            value: inputValue
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = valueDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!valueDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.add(valueDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/strictObject/strictObject.ts
function strictObject(entries, message) {
    return {
        kind: "schema",
        type: "strict_object",
        reference: strictObject,
        expects: "Object",
        async: false,
        entries,
        message,
        _run (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                for(const key in this.entries){
                    const value2 = input[key];
                    const valueDataset = this.entries[key]._run({
                        typed: false,
                        value: value2
                    }, config2);
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "object",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = valueDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!valueDataset.typed) {
                        dataset.typed = false;
                    }
                    if (valueDataset.value !== void 0 || key in input) {
                        dataset.value[key] = valueDataset.value;
                    }
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(const key in input){
                        if (!(key in this.entries)) {
                            const value2 = input[key];
                            _addIssue(this, "type", dataset, config2, {
                                input: value2,
                                expected: "never",
                                path: [
                                    {
                                        type: "object",
                                        origin: "value",
                                        input,
                                        key,
                                        value: value2
                                    }
                                ]
                            });
                            break;
                        }
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/strictObject/strictObjectAsync.ts
function strictObjectAsync(entries, message) {
    return {
        kind: "schema",
        type: "strict_object",
        reference: strictObjectAsync,
        expects: "Object",
        async: true,
        entries,
        message,
        async _run (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                dataset.typed = true;
                dataset.value = {};
                const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, schema])=>{
                    const value2 = input[key];
                    return [
                        key,
                        value2,
                        await schema._run({
                            typed: false,
                            value: value2
                        }, config2)
                    ];
                }));
                for (const [key, value2, valueDataset] of valueDatasets){
                    if (valueDataset.issues) {
                        const pathItem = {
                            type: "object",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of valueDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = valueDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!valueDataset.typed) {
                        dataset.typed = false;
                    }
                    if (valueDataset.value !== void 0 || key in input) {
                        dataset.value[key] = valueDataset.value;
                    }
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(const key in input){
                        if (!(key in this.entries)) {
                            const value2 = input[key];
                            _addIssue(this, "type", dataset, config2, {
                                input: value2,
                                expected: "never",
                                path: [
                                    {
                                        type: "object",
                                        origin: "value",
                                        input,
                                        key,
                                        value: value2
                                    }
                                ]
                            });
                            break;
                        }
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/strictTuple/strictTuple.ts
function strictTuple(items, message) {
    return {
        kind: "schema",
        type: "strict_tuple",
        reference: strictTuple,
        expects: "Array",
        async: false,
        items,
        message,
        _run (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                for(let key = 0; key < items.length; key++){
                    const value2 = input[key];
                    const itemDataset = this.items[key]._run({
                        typed: false,
                        value: value2
                    }, config2);
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "tuple",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
                if (!(dataset.issues && config2.abortEarly) && items.length < input.length) {
                    const value2 = input[items.length];
                    _addIssue(this, "type", dataset, config2, {
                        input: value2,
                        expected: "never",
                        path: [
                            {
                                type: "tuple",
                                origin: "value",
                                input,
                                key: items.length,
                                value: value2
                            }
                        ]
                    });
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/strictTuple/strictTupleAsync.ts
function strictTupleAsync(items, message) {
    return {
        kind: "schema",
        type: "strict_tuple",
        reference: strictTupleAsync,
        expects: "Array",
        async: true,
        items,
        message,
        async _run (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                const itemDatasets = await Promise.all(items.map(async (item, key)=>{
                    const value2 = input[key];
                    return [
                        key,
                        value2,
                        await item._run({
                            typed: false,
                            value: value2
                        }, config2)
                    ];
                }));
                for (const [key, value2, itemDataset] of itemDatasets){
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "tuple",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
                if (!(dataset.issues && config2.abortEarly) && items.length < input.length) {
                    const value2 = input[items.length];
                    _addIssue(this, "type", dataset, config2, {
                        input: value2,
                        expected: "never",
                        path: [
                            {
                                type: "tuple",
                                origin: "value",
                                input,
                                key: items.length,
                                value: value2
                            }
                        ]
                    });
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/string/string.ts
function string(message) {
    return {
        kind: "schema",
        type: "string",
        reference: string,
        expects: "string",
        async: false,
        message,
        _run (dataset, config2) {
            if (typeof dataset.value === "string") {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/symbol/symbol.ts
function symbol(message) {
    return {
        kind: "schema",
        type: "symbol",
        reference: symbol,
        expects: "symbol",
        async: false,
        message,
        _run (dataset, config2) {
            if (typeof dataset.value === "symbol") {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/tuple/tuple.ts
function tuple(items, message) {
    return {
        kind: "schema",
        type: "tuple",
        reference: tuple,
        expects: "Array",
        async: false,
        items,
        message,
        _run (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                for(let key = 0; key < items.length; key++){
                    const value2 = input[key];
                    const itemDataset = this.items[key]._run({
                        typed: false,
                        value: value2
                    }, config2);
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "tuple",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/tuple/tupleAsync.ts
function tupleAsync(items, message) {
    return {
        kind: "schema",
        type: "tuple",
        reference: tupleAsync,
        expects: "Array",
        async: true,
        items,
        message,
        async _run (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                const itemDatasets = await Promise.all(items.map(async (item, key)=>{
                    const value2 = input[key];
                    return [
                        key,
                        value2,
                        await item._run({
                            typed: false,
                            value: value2
                        }, config2)
                    ];
                }));
                for (const [key, value2, itemDataset] of itemDatasets){
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "tuple",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/tupleWithRest/tupleWithRest.ts
function tupleWithRest(items, rest, message) {
    return {
        kind: "schema",
        type: "tuple_with_rest",
        reference: tupleWithRest,
        expects: "Array",
        async: false,
        items,
        rest,
        message,
        _run (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                for(let key = 0; key < items.length; key++){
                    const value2 = input[key];
                    const itemDataset = this.items[key]._run({
                        typed: false,
                        value: value2
                    }, config2);
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "tuple",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for(let key = items.length; key < input.length; key++){
                        const value2 = input[key];
                        const itemDataset = this.rest._run({
                            typed: false,
                            value: value2
                        }, config2);
                        if (itemDataset.issues) {
                            const pathItem = {
                                type: "tuple",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of itemDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = itemDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!itemDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value.push(itemDataset.value);
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/tupleWithRest/tupleWithRestAsync.ts
function tupleWithRestAsync(items, rest, message) {
    return {
        kind: "schema",
        type: "tuple_with_rest",
        reference: tupleWithRestAsync,
        expects: "Array",
        async: true,
        items,
        rest,
        message,
        async _run (dataset, config2) {
            const input = dataset.value;
            if (Array.isArray(input)) {
                dataset.typed = true;
                dataset.value = [];
                const [normalDatasets, restDatasets] = await Promise.all([
                    // Parse schema of each normal item
                    Promise.all(items.map(async (item, key)=>{
                        const value2 = input[key];
                        return [
                            key,
                            value2,
                            await item._run({
                                typed: false,
                                value: value2
                            }, config2)
                        ];
                    })),
                    // Parse other items with rest schema
                    Promise.all(input.slice(items.length).map(async (value2, key)=>{
                        return [
                            key + items.length,
                            value2,
                            await rest._run({
                                typed: false,
                                value: value2
                            }, config2)
                        ];
                    }))
                ]);
                for (const [key, value2, itemDataset] of normalDatasets){
                    if (itemDataset.issues) {
                        const pathItem = {
                            type: "tuple",
                            origin: "value",
                            input,
                            key,
                            value: value2
                        };
                        for (const issue of itemDataset.issues){
                            if (issue.path) {
                                issue.path.unshift(pathItem);
                            } else {
                                issue.path = [
                                    pathItem
                                ];
                            }
                            dataset.issues?.push(issue);
                        }
                        if (!dataset.issues) {
                            dataset.issues = itemDataset.issues;
                        }
                        if (config2.abortEarly) {
                            dataset.typed = false;
                            break;
                        }
                    }
                    if (!itemDataset.typed) {
                        dataset.typed = false;
                    }
                    dataset.value.push(itemDataset.value);
                }
                if (!dataset.issues || !config2.abortEarly) {
                    for (const [key, value2, itemDataset] of restDatasets){
                        if (itemDataset.issues) {
                            const pathItem = {
                                type: "tuple",
                                origin: "value",
                                input,
                                key,
                                value: value2
                            };
                            for (const issue of itemDataset.issues){
                                if (issue.path) {
                                    issue.path.unshift(pathItem);
                                } else {
                                    issue.path = [
                                        pathItem
                                    ];
                                }
                                dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                                dataset.issues = itemDataset.issues;
                            }
                            if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                            }
                        }
                        if (!itemDataset.typed) {
                            dataset.typed = false;
                        }
                        dataset.value.push(itemDataset.value);
                    }
                }
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/undefined/undefined.ts
function undefined_(message) {
    return {
        kind: "schema",
        type: "undefined",
        reference: undefined_,
        expects: "undefined",
        async: false,
        message,
        _run (dataset, config2) {
            if (dataset.value === void 0) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/union/utils/_subIssues/_subIssues.ts
function _subIssues(datasets) {
    let issues;
    if (datasets) {
        for (const dataset of datasets){
            if (issues) {
                issues.push(...dataset.issues);
            } else {
                issues = dataset.issues;
            }
        }
    }
    return issues;
}
// src/schemas/union/union.ts
function union(options, message) {
    return {
        kind: "schema",
        type: "union",
        reference: union,
        expects: [
            ...new Set(options.map((option)=>option.expects))
        ].join(" | ") || "never",
        async: false,
        options,
        message,
        _run (dataset, config2) {
            let validDataset;
            let typedDatasets;
            let untypedDatasets;
            for (const schema of this.options){
                const optionDataset = schema._run({
                    typed: false,
                    value: dataset.value
                }, config2);
                if (optionDataset.typed) {
                    if (optionDataset.issues) {
                        if (typedDatasets) {
                            typedDatasets.push(optionDataset);
                        } else {
                            typedDatasets = [
                                optionDataset
                            ];
                        }
                    } else {
                        validDataset = optionDataset;
                        break;
                    }
                } else {
                    if (untypedDatasets) {
                        untypedDatasets.push(optionDataset);
                    } else {
                        untypedDatasets = [
                            optionDataset
                        ];
                    }
                }
            }
            if (validDataset) {
                return validDataset;
            }
            if (typedDatasets) {
                if (typedDatasets.length === 1) {
                    return typedDatasets[0];
                }
                _addIssue(this, "type", dataset, config2, {
                    issues: _subIssues(typedDatasets)
                });
                dataset.typed = true;
            } else if (untypedDatasets?.length === 1) {
                return untypedDatasets[0];
            } else {
                _addIssue(this, "type", dataset, config2, {
                    issues: _subIssues(untypedDatasets)
                });
            }
            return dataset;
        }
    };
}
// src/schemas/union/unionAsync.ts
function unionAsync(options, message) {
    return {
        kind: "schema",
        type: "union",
        reference: unionAsync,
        expects: [
            ...new Set(options.map((option)=>option.expects))
        ].join(" | ") || "never",
        async: true,
        options,
        message,
        async _run (dataset, config2) {
            let validDataset;
            let typedDatasets;
            let untypedDatasets;
            for (const schema of this.options){
                const optionDataset = await schema._run({
                    typed: false,
                    value: dataset.value
                }, config2);
                if (optionDataset.typed) {
                    if (optionDataset.issues) {
                        if (typedDatasets) {
                            typedDatasets.push(optionDataset);
                        } else {
                            typedDatasets = [
                                optionDataset
                            ];
                        }
                    } else {
                        validDataset = optionDataset;
                        break;
                    }
                } else {
                    if (untypedDatasets) {
                        untypedDatasets.push(optionDataset);
                    } else {
                        untypedDatasets = [
                            optionDataset
                        ];
                    }
                }
            }
            if (validDataset) {
                return validDataset;
            }
            if (typedDatasets) {
                if (typedDatasets.length === 1) {
                    return typedDatasets[0];
                }
                _addIssue(this, "type", dataset, config2, {
                    issues: _subIssues(typedDatasets)
                });
                dataset.typed = true;
            } else if (untypedDatasets?.length === 1) {
                return untypedDatasets[0];
            } else {
                _addIssue(this, "type", dataset, config2, {
                    issues: _subIssues(untypedDatasets)
                });
            }
            return dataset;
        }
    };
}
// src/schemas/unknown/unknown.ts
function unknown() {
    return {
        kind: "schema",
        type: "unknown",
        reference: unknown,
        expects: "unknown",
        async: false,
        _run (dataset) {
            dataset.typed = true;
            return dataset;
        }
    };
}
// src/schemas/variant/utils/_discriminators/_discriminators.ts
function _discriminators(key, options, set2 = /* @__PURE__ */ new Set()) {
    for (const schema of options){
        if (schema.type === "variant") {
            _discriminators(key, schema.options, set2);
        } else {
            set2.add(schema.entries[key].expects);
        }
    }
    return set2;
}
// src/schemas/variant/variant.ts
function variant(key, options, message) {
    let expectedDiscriminators;
    return {
        kind: "schema",
        type: "variant",
        reference: variant,
        expects: "Object",
        async: false,
        key,
        options,
        message,
        _run (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                const discriminator = input[this.key];
                if (this.key in input) {
                    let outputDataset;
                    for (const schema of this.options){
                        if (schema.type === "variant" || !schema.entries[this.key]._run({
                            typed: false,
                            value: discriminator
                        }, config2).issues) {
                            const optionDataset = schema._run({
                                typed: false,
                                value: input
                            }, config2);
                            if (!optionDataset.issues) {
                                return optionDataset;
                            }
                            if (!outputDataset || !outputDataset.typed && optionDataset.typed) {
                                outputDataset = optionDataset;
                            }
                        }
                    }
                    if (outputDataset) {
                        return outputDataset;
                    }
                }
                if (!expectedDiscriminators) {
                    expectedDiscriminators = [
                        ..._discriminators(this.key, this.options)
                    ].join(" | ") || "never";
                }
                _addIssue(this, "type", dataset, config2, {
                    input: discriminator,
                    expected: expectedDiscriminators,
                    path: [
                        {
                            type: "object",
                            origin: "value",
                            input,
                            key: this.key,
                            value: discriminator
                        }
                    ]
                });
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/variant/variantAsync.ts
function variantAsync(key, options, message) {
    let expectedDiscriminators;
    return {
        kind: "schema",
        type: "variant",
        reference: variantAsync,
        expects: "Object",
        async: true,
        key,
        options,
        message,
        async _run (dataset, config2) {
            const input = dataset.value;
            if (input && typeof input === "object") {
                const discriminator = input[this.key];
                if (this.key in input) {
                    let outputDataset;
                    for (const schema of this.options){
                        if (schema.type === "variant" || !(await schema.entries[this.key]._run({
                            typed: false,
                            value: discriminator
                        }, config2)).issues) {
                            const optionDataset = await schema._run({
                                typed: false,
                                value: input
                            }, config2);
                            if (!optionDataset.issues) {
                                return optionDataset;
                            }
                            if (!outputDataset || !outputDataset.typed && optionDataset.typed) {
                                outputDataset = optionDataset;
                            }
                        }
                    }
                    if (outputDataset) {
                        return outputDataset;
                    }
                }
                if (!expectedDiscriminators) {
                    expectedDiscriminators = [
                        ..._discriminators(this.key, this.options)
                    ].join(" | ") || "never";
                }
                _addIssue(this, "type", dataset, config2, {
                    input: discriminator,
                    expected: expectedDiscriminators,
                    path: [
                        {
                            type: "object",
                            origin: "value",
                            input,
                            key: this.key,
                            value: discriminator
                        }
                    ]
                });
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/schemas/void/void.ts
function void_(message) {
    return {
        kind: "schema",
        type: "void",
        reference: void_,
        expects: "void",
        async: false,
        message,
        _run (dataset, config2) {
            if (dataset.value === void 0) {
                dataset.typed = true;
            } else {
                _addIssue(this, "type", dataset, config2);
            }
            return dataset;
        }
    };
}
// src/methods/keyof/keyof.ts
function keyof(schema, message) {
    return picklist(Object.keys(schema.entries), message);
}
// src/methods/omit/omit.ts
function omit(schema, keys) {
    const entries = {
        ...schema.entries
    };
    for (const key of keys){
        delete entries[key];
    }
    return {
        ...schema,
        entries
    };
}
// src/methods/parse/parse.ts
function parse(schema, input, config2) {
    const dataset = schema._run({
        typed: false,
        value: input
    }, getGlobalConfig(config2));
    if (dataset.issues) {
        throw new ValiError(dataset.issues);
    }
    return dataset.value;
}
// src/methods/parse/parseAsync.ts
async function parseAsync(schema, input, config2) {
    const dataset = await schema._run({
        typed: false,
        value: input
    }, getGlobalConfig(config2));
    if (dataset.issues) {
        throw new ValiError(dataset.issues);
    }
    return dataset.value;
}
// src/methods/parser/parser.ts
function parser(schema, config2) {
    const func = (input)=>parse(schema, input, config2);
    func.schema = schema;
    func.config = config2;
    return func;
}
// src/methods/parser/parserAsync.ts
function parserAsync(schema, config2) {
    const func = (input)=>parseAsync(schema, input, config2);
    func.schema = schema;
    func.config = config2;
    return func;
}
// src/methods/partial/partial.ts
function partial(schema, keys) {
    const entries = {};
    for(const key in schema.entries){
        entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];
    }
    return {
        ...schema,
        entries
    };
}
// src/methods/partial/partialAsync.ts
function partialAsync(schema, keys) {
    const entries = {};
    for(const key in schema.entries){
        entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];
    }
    return {
        ...schema,
        entries
    };
}
// src/methods/pick/pick.ts
function pick(schema, keys) {
    const entries = {};
    for (const key of keys){
        entries[key] = schema.entries[key];
    }
    return {
        ...schema,
        entries
    };
}
// src/methods/pipe/pipe.ts
function pipe(...pipe2) {
    return {
        ...pipe2[0],
        pipe: pipe2,
        _run (dataset, config2) {
            for(let index = 0; index < pipe2.length; index++){
                dataset = pipe2[index]._run(dataset, config2);
                const nextAction = pipe2[index + 1];
                if (config2.skipPipe || dataset.issues && (config2.abortEarly || config2.abortPipeEarly || // TODO: This behavior must be documented!
                nextAction?.kind === "schema" || nextAction?.kind === "transformation")) {
                    dataset.typed = false;
                    break;
                }
            }
            return dataset;
        }
    };
}
// src/methods/pipe/pipeAsync.ts
function pipeAsync(...pipe2) {
    return {
        ...pipe2[0],
        pipe: pipe2,
        async: true,
        async _run (dataset, config2) {
            for(let index = 0; index < pipe2.length; index++){
                dataset = await pipe2[index]._run(dataset, config2);
                const nextAction = pipe2[index + 1];
                if (config2.skipPipe || dataset.issues && (config2.abortEarly || config2.abortPipeEarly || // TODO: This behavior must be documented!
                nextAction?.kind === "schema" || nextAction?.kind === "transformation")) {
                    dataset.typed = false;
                    break;
                }
            }
            return dataset;
        }
    };
}
// src/methods/required/required.ts
function required(schema, arg2, arg3) {
    const keys = Array.isArray(arg2) ? arg2 : void 0;
    const message = Array.isArray(arg2) ? arg3 : arg2;
    const entries = {};
    for(const key in schema.entries){
        entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];
    }
    return {
        ...schema,
        entries
    };
}
// src/methods/required/requiredAsync.ts
function requiredAsync(schema, arg2, arg3) {
    const keys = Array.isArray(arg2) ? arg2 : void 0;
    const message = Array.isArray(arg2) ? arg3 : arg2;
    const entries = {};
    for(const key in schema.entries){
        entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];
    }
    return {
        ...schema,
        entries
    };
}
// src/methods/safeParse/safeParse.ts
function safeParse(schema, input, config2) {
    const dataset = schema._run({
        typed: false,
        value: input
    }, getGlobalConfig(config2));
    return {
        typed: dataset.typed,
        success: !dataset.issues,
        output: dataset.value,
        issues: dataset.issues
    };
}
// src/methods/safeParse/safeParseAsync.ts
async function safeParseAsync(schema, input, config2) {
    const dataset = await schema._run({
        typed: false,
        value: input
    }, getGlobalConfig(config2));
    return {
        typed: dataset.typed,
        success: !dataset.issues,
        output: dataset.value,
        issues: dataset.issues
    };
}
// src/methods/safeParser/safeParser.ts
function safeParser(schema, config2) {
    const func = (input)=>safeParse(schema, input, config2);
    func.schema = schema;
    func.config = config2;
    return func;
}
// src/methods/safeParser/safeParserAsync.ts
function safeParserAsync(schema, config2) {
    const func = (input)=>safeParseAsync(schema, input, config2);
    func.schema = schema;
    func.config = config2;
    return func;
}
// src/methods/unwrap/unwrap.ts
function unwrap(schema) {
    return schema.wrapped;
}
;
}}),
"[project]/node_modules/@sanity/visual-editing-csm/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createDataAttribute": (()=>createDataAttribute),
    "decodeSanityNodeData": (()=>decodeSanityNodeData),
    "encodeSanityNodeData": (()=>encodeSanityNodeData),
    "pathToUrlString": (()=>pathToUrlString),
    "urlStringToPath": (()=>urlStringToPath)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/client/dist/_chunks-es/resolveEditInfo.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/valibot/dist/index.js [app-client] (ecmascript)");
;
;
const lengthyStr$1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pipe"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"])(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["minLength"])(1)), optionalLengthyStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optional"])(lengthyStr$1), sanityNodeSchema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["object"])({
    baseUrl: lengthyStr$1,
    dataset: optionalLengthyStr,
    id: lengthyStr$1,
    path: lengthyStr$1,
    projectId: optionalLengthyStr,
    tool: optionalLengthyStr,
    type: optionalLengthyStr,
    workspace: optionalLengthyStr
});
function isValidSanityNode(node) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["is"])(sanityNodeSchema, node);
}
function isArray(value) {
    return value !== null && Array.isArray(value);
}
function pathToUrlString(path) {
    let str = "";
    for (const segment of path){
        if (typeof segment == "string") {
            str && (str += "."), str += segment;
            continue;
        }
        if (typeof segment == "number") {
            str && (str += ":"), str += `${segment}`;
            continue;
        }
        if (isArray(segment)) {
            str && (str += ":"), str += `${segment.join(",")}}`;
            continue;
        }
        if (segment._key) {
            str && (str += ":"), str += `${segment._key}`;
            continue;
        }
    }
    return str;
}
function encodeSanityNodeData(node) {
    const { id: _id, path, baseUrl, tool, workspace, type } = node;
    return isValidSanityNode(node) ? [
        [
            "id",
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPublishedId"])(_id)
        ],
        [
            "type",
            type
        ],
        [
            "path",
            pathToUrlString(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["studioPath"].fromString(path))
        ],
        [
            "base",
            encodeURIComponent(baseUrl)
        ],
        [
            "workspace",
            workspace
        ],
        [
            "tool",
            tool
        ]
    ].filter(([, value])=>!!value).map((part)=>part.join("=")).join(";") : void 0;
}
function createDataAttribute(props) {
    function normalizePath(path) {
        return path ? typeof path == "string" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["studioPath"].fromString(path) : path : [];
    }
    function toString(props2) {
        if (!props2.id) throw new Error("`id` is required to create a data attribute");
        if (!props2.type) throw new Error("`type` is required to create a data attribute");
        if (!props2.path || !props2.path.length) throw new Error("`path` is required to create a data attribute");
        const attrs = {
            baseUrl: props2.baseUrl || "/",
            workspace: props2.workspace,
            tool: props2.tool,
            type: props2.type,
            id: props2.id,
            path: typeof props2.path == "string" ? props2.path : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["studioPath"].toString(props2.path)
        };
        return encodeSanityNodeData(attrs);
    }
    const DataAttribute = (path)=>toString({
            ...props,
            path: [
                ...normalizePath(props.path),
                ...normalizePath(path)
            ]
        });
    return DataAttribute.toString = function() {
        return toString(props);
    }, DataAttribute.combine = function(attrs) {
        return createDataAttribute({
            ...props,
            ...attrs
        });
    }, DataAttribute.scope = function(path) {
        return createDataAttribute({
            ...props,
            path: [
                ...normalizePath(props.path),
                ...normalizePath(path)
            ]
        });
    }, DataAttribute;
}
const RE_SEGMENT_WITH_INDEX = /^([\w-]+):(0|[1-9][0-9]*)$/, RE_SEGMENT_WITH_TUPLE = /^([\w-]+):([0-9]+),([0-9]+)$/, RE_SEGMENT_WITH_KEY = /^([\w-]+):([\w-]+)$/;
function urlStringToPath(str) {
    const path = [];
    for (const segment of str.split(".")){
        const withIndex = RE_SEGMENT_WITH_INDEX.exec(segment);
        if (withIndex) {
            path.push(withIndex[1], Number(withIndex[2]));
            continue;
        }
        const withTuple = RE_SEGMENT_WITH_TUPLE.exec(segment);
        if (withTuple) {
            path.push(withTuple[1], [
                Number(withTuple[2]),
                Number(withTuple[3])
            ]);
            continue;
        }
        const withKey = RE_SEGMENT_WITH_KEY.exec(segment);
        if (withKey) {
            path.push(withKey[1], {
                _key: withKey[2]
            });
            continue;
        }
        path.push(segment);
    }
    return path;
}
const lengthyStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pipe"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"])(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["minLength"])(1)), sanityLegacyNodeSchema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["object"])({
    origin: lengthyStr,
    href: lengthyStr,
    data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optional"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["record"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"])(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unknown"])()))
});
function decodeSanityString(str) {
    const data = str.split(";").reduce((acc, segment)=>{
        const [key, value] = segment.split("=");
        if (!key || segment.includes("=") && !value) return acc;
        switch(key){
            case "id":
                acc.id = value;
                break;
            case "type":
                acc.type = value;
                break;
            case "path":
                acc.path = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["studioPath"].toString(urlStringToPath(value));
                break;
            case "base":
                acc.baseUrl = decodeURIComponent(value);
                break;
            case "tool":
                acc.tool = value;
                break;
            case "workspace":
                acc.workspace = value;
                break;
            case "projectId":
                acc.projectId = value;
                break;
            case "dataset":
                acc.dataset = value;
                break;
        }
        return acc;
    }, {});
    if (isValidSanityNode(data)) return data;
}
function decodeSanityObject(data) {
    const sanityNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["safeParse"])(sanityNodeSchema, data);
    if (sanityNode.success) return sanityNode.output;
    const sanityLegacyNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["safeParse"])(sanityLegacyNodeSchema, data);
    if (sanityLegacyNode.success) try {
        const url = new URL(sanityLegacyNode.output.href, typeof document > "u" ? "https://example.com" : location.origin);
        return url.searchParams.size > 0 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$valibot$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(sanityNodeSchema, Object.fromEntries(url.searchParams.entries())) : sanityLegacyNode.output;
    } catch (err) {
        return console.error("Failed to parse sanity node", err), sanityLegacyNode.output;
    }
}
function decodeSanityNodeData(data) {
    if (typeof data == "object" && data !== null) return decodeSanityObject(data);
    try {
        const obj = JSON.parse(data);
        return decodeSanityObject(obj);
    } catch  {
        return decodeSanityString(data);
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@vercel/stega/dist/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "VERCEL_STEGA_REGEX": (()=>f),
    "legacyStegaEncode": (()=>y),
    "vercelStegaClean": (()=>O),
    "vercelStegaCombine": (()=>C),
    "vercelStegaDecode": (()=>G),
    "vercelStegaDecodeAll": (()=>$),
    "vercelStegaEncode": (()=>E),
    "vercelStegaSplit": (()=>_)
});
var s = {
    0: 8203,
    1: 8204,
    2: 8205,
    3: 8290,
    4: 8291,
    5: 8288,
    6: 65279,
    7: 8289,
    8: 119155,
    9: 119156,
    a: 119157,
    b: 119158,
    c: 119159,
    d: 119160,
    e: 119161,
    f: 119162
}, c = {
    0: 8203,
    1: 8204,
    2: 8205,
    3: 65279
}, u = new Array(4).fill(String.fromCodePoint(c[0])).join(""), m = String.fromCharCode(0);
function E(t) {
    let e = JSON.stringify(t);
    return `${u}${Array.from(e).map((r)=>{
        let n = r.charCodeAt(0);
        if (n > 255) throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);
        return Array.from(n.toString(4).padStart(4, "0")).map((o)=>String.fromCodePoint(c[o])).join("");
    }).join("")}`;
}
function y(t) {
    let e = JSON.stringify(t);
    return Array.from(e).map((r)=>{
        let n = r.charCodeAt(0);
        if (n > 255) throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);
        return Array.from(n.toString(16).padStart(2, "0")).map((o)=>String.fromCodePoint(s[o])).join("");
    }).join("");
}
function I(t) {
    return !Number.isNaN(Number(t)) || /[a-z]/i.test(t) && !/\d+(?:[-:\/]\d+){2}(?:T\d+(?:[-:\/]\d+){1,2}(\.\d+)?Z?)?/.test(t) ? !1 : Boolean(Date.parse(t));
}
function T(t) {
    try {
        new URL(t, t.startsWith("/") ? "https://acme.com" : void 0);
    } catch  {
        return !1;
    }
    return !0;
}
function C(t, e, r = "auto") {
    return r === !0 || r === "auto" && (I(t) || T(t)) ? t : `${t}${E(e)}`;
}
var x = Object.fromEntries(Object.entries(c).map((t)=>t.reverse())), g = Object.fromEntries(Object.entries(s).map((t)=>t.reverse())), S = `${Object.values(s).map((t)=>`\\u{${t.toString(16)}}`).join("")}`, f = new RegExp(`[${S}]{4,}`, "gu");
function G(t) {
    let e = t.match(f);
    if (!!e) return h(e[0], !0)[0];
}
function $(t) {
    let e = t.match(f);
    if (!!e) return e.map((r)=>h(r)).flat();
}
function h(t, e = !1) {
    let r = Array.from(t);
    if (r.length % 2 === 0) {
        if (r.length % 4 || !t.startsWith(u)) return A(r, e);
    } else throw new Error("Encoded data has invalid length");
    let n = [];
    for(let o = r.length * .25; o--;){
        let p = r.slice(o * 4, o * 4 + 4).map((d)=>x[d.codePointAt(0)]).join("");
        n.unshift(String.fromCharCode(parseInt(p, 4)));
    }
    if (e) {
        n.shift();
        let o = n.indexOf(m);
        return o === -1 && (o = n.length), [
            JSON.parse(n.slice(0, o).join(""))
        ];
    }
    return n.join("").split(m).filter(Boolean).map((o)=>JSON.parse(o));
}
function A(t, e) {
    var d;
    let r = [];
    for(let i = t.length * .5; i--;){
        let a = `${g[t[i * 2].codePointAt(0)]}${g[t[i * 2 + 1].codePointAt(0)]}`;
        r.unshift(String.fromCharCode(parseInt(a, 16)));
    }
    let n = [], o = [
        r.join("")
    ], p = 10;
    for(; o.length;){
        let i = o.shift();
        try {
            if (n.push(JSON.parse(i)), e) return n;
        } catch (a) {
            if (!p--) throw a;
            let l = +((d = a.message.match(/\sposition\s(\d+)$/)) == null ? void 0 : d[1]);
            if (!l) throw a;
            o.unshift(i.substring(0, l), i.substring(l));
        }
    }
    return n;
}
function _(t) {
    var e;
    return {
        cleaned: t.replace(f, ""),
        encoded: ((e = t.match(f)) == null ? void 0 : e[0]) || ""
    };
}
function O(t) {
    return t && JSON.parse(_(JSON.stringify(t)).cleaned);
}
;
}}),
"[project]/node_modules/@sanity/visual-editing/dist/_chunks-es/SharedStateContext.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "SharedStateContext": (()=>SharedStateContext),
    "createOverlayController": (()=>createOverlayController),
    "sanityNodesExistInSameArray": (()=>sanityNodesExistInSameArray),
    "useOptimistic": (()=>useOptimistic)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-compiler-runtime/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/client/dist/_chunks-es/resolveEditInfo.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react-experimental/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$effect$2d$event$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/use-effect-event/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/visual-editing/dist/_chunks-es/context.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$mutations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/visual-editing/dist/_chunks-es/mutations.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2d$csm$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/visual-editing-csm/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vercel$2f$stega$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@vercel/stega/dist/index.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
function useOptimistic(passthrough, reducer) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(21), [pristine, setPristine] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(!0), [optimistic, setOptimistic] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(passthrough), [lastEvent, setLastEvent] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(null), [lastPassthrough, setLastPassthrough] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(passthrough), actor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$mutations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useOptimisticActor"])();
    let t0;
    $[0] !== reducer ? (t0 = (action, prevState)=>(Array.isArray(reducer) ? reducer : [
            reducer
        ]).reduce((acc, reducer_0)=>reducer_0(acc, {
                document: action.document,
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPublishedId"])(action.id),
                originalId: action.id,
                type: action.type
            }), prevState), $[0] = reducer, $[1] = t0) : t0 = $[1];
    const reduceStateFromAction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$effect$2d$event$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffectEvent"])(t0);
    let t1;
    $[2] !== passthrough ? (t1 = ()=>setLastPassthrough(passthrough), $[2] = passthrough, $[3] = t1) : t1 = $[3];
    const updateLastPassthrough = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$effect$2d$event$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffectEvent"])(t1);
    let t2;
    $[4] !== actor || $[5] !== reduceStateFromAction || $[6] !== updateLastPassthrough ? (t2 = ()=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2f$dist$2f$_chunks$2d$es$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEmptyActor"])(actor)) return;
        let pristineTimeout;
        const rebasedSub = actor.on("rebased.local", (_event)=>{
            const event = {
                document: _event.document,
                id: _event.id,
                originalId: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPublishedId"])(_event.id),
                type: "mutate"
            };
            setOptimistic((prevState_0)=>reduceStateFromAction(event, prevState_0)), setLastEvent(event), updateLastPassthrough(), setPristine(!1), clearTimeout(pristineTimeout);
        }), pristineSub = actor.on("pristine", ()=>{
            pristineTimeout = setTimeout(()=>{
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["startTransition"])(()=>setPristine(!0));
            }, 15e3);
        });
        return ()=>{
            rebasedSub.unsubscribe(), pristineSub.unsubscribe();
        };
    }, $[4] = actor, $[5] = reduceStateFromAction, $[6] = updateLastPassthrough, $[7] = t2) : t2 = $[7];
    let t3;
    $[8] !== actor ? (t3 = [
        actor
    ], $[8] = actor, $[9] = t3) : t3 = $[9], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(t2, t3);
    let t4;
    $[10] !== lastEvent || $[11] !== lastPassthrough || $[12] !== passthrough || $[13] !== pristine || $[14] !== reduceStateFromAction ? (t4 = ()=>{
        if (!pristine) {
            if (!lastEvent) throw new Error("No last event found when syncing passthrough");
            lastPassthrough !== passthrough && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["startTransition"])(()=>{
                setOptimistic(reduceStateFromAction(lastEvent, passthrough)), setLastPassthrough(passthrough);
            });
        }
    }, $[10] = lastEvent, $[11] = lastPassthrough, $[12] = passthrough, $[13] = pristine, $[14] = reduceStateFromAction, $[15] = t4) : t4 = $[15];
    let t5;
    return $[16] !== lastEvent || $[17] !== lastPassthrough || $[18] !== passthrough || $[19] !== pristine ? (t5 = [
        lastEvent,
        lastPassthrough,
        passthrough,
        pristine
    ], $[16] = lastEvent, $[17] = lastPassthrough, $[18] = passthrough, $[19] = pristine, $[20] = t5) : t5 = $[20], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(t4, t5), pristine ? passthrough : optimistic;
}
const byteToHex = [];
for(let i = 0; i < 256; ++i)byteToHex.push((i + 256).toString(16).slice(1));
function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
    if (!getRandomValues) {
        if (typeof crypto > "u" || !crypto.getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        getRandomValues = crypto.getRandomValues.bind(crypto);
    }
    return getRandomValues(rnds8);
}
const randomUUID = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native = {
    randomUUID
};
function v4(options, buf, offset) {
    if (native.randomUUID && !options) return native.randomUUID();
    options = options || {};
    const rnds = options.random ?? options.rng?.() ?? rng();
    if (rnds.length < 16) throw new Error("Random bytes length must be >= 16");
    return rnds[6] = rnds[6] & 15 | 64, rnds[8] = rnds[8] & 63 | 128, unsafeStringify(rnds);
}
function getRect(element) {
    const domRect = element.getBoundingClientRect();
    return {
        x: domRect.x + scrollX,
        y: domRect.y + scrollY,
        w: domRect.width,
        h: domRect.height
    };
}
function offsetRect(rect, px, axis) {
    return axis === "x" ? {
        x: rect.x + px,
        y: rect.y,
        w: rect.w - 2 * px,
        h: rect.h
    } : {
        x: rect.x,
        y: rect.y + px,
        w: rect.w,
        h: rect.h - 2 * px
    };
}
function rayIntersect(l1, l2) {
    const { x1, y1, x2, y2 } = l1, { x1: x3, y1: y3, x2: x4, y2: y4 } = l2;
    if (x1 === x2 && y1 === y2 || x3 === x4 && y3 === y4) return !1;
    const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
    if (denominator === 0) return !1;
    const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator, ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;
    if (ua < 0 || ua > 1 || ub < 0 || ub > 1) return !1;
    const x = x1 + ua * (x2 - x1), y = y1 + ua * (y2 - y1);
    return {
        x,
        y
    };
}
function rectEqual(r1, r2) {
    return r1.x === r2.x && r1.y === r2.y && r1.w === r2.w && r1.h === r2.h;
}
function rayRectIntersections(line, rect) {
    const rectLines = [
        {
            x1: rect.x,
            y1: rect.y,
            x2: rect.x + rect.w,
            y2: rect.y
        },
        {
            x1: rect.x + rect.w,
            y1: rect.y,
            x2: rect.x + rect.w,
            y2: rect.y + rect.h
        },
        {
            x1: rect.x + rect.w,
            y1: rect.y + rect.h,
            x2: rect.x,
            y2: rect.y + rect.h
        },
        {
            x1: rect.x,
            y1: rect.y + rect.h,
            x2: rect.x,
            y2: rect.y
        }
    ], intersections = [];
    for(let i = 0; i < rectLines.length; i++){
        const intersection = rayIntersect(line, rectLines[i]);
        if (intersection) {
            let isDuplicate = !1;
            for(let j = 0; j < intersections.length; j++)intersections[j].x === intersection.x && intersections[j].y === intersection.y && (isDuplicate = !0);
            isDuplicate || intersections.push(intersection);
        }
    }
    return intersections.length === 0 ? !1 : intersections.sort((a, b)=>pointDist(a, {
            x: line.x1,
            y: line.y1
        }) - pointDist(b, {
            x: line.x1,
            y: line.y1
        }));
}
function pointDist(p1, p2) {
    const a = p1.x - p2.x, b = p1.y - p2.y;
    return Math.sqrt(a * a + b * b);
}
function pointInBounds(point, bounds) {
    const withinX = point.x >= bounds.x && point.x <= bounds.x + bounds.w, withinY = point.y >= bounds.y && point.y <= bounds.y + bounds.h;
    return withinX && withinY;
}
function findClosestIntersection(ray, targets, flow) {
    const rayOrigin = {
        x: ray.x1,
        y: ray.y1
    };
    if (targets.some((t)=>pointInBounds(rayOrigin, offsetRect(t, Math.min(t.w, t.h) / 10, flow === "horizontal" ? "x" : "y")))) return null;
    let closestIntersection, closestRect;
    for (const target of targets){
        const intersections = rayRectIntersections(ray, offsetRect(target, Math.min(target.w, target.h) / 10, flow === "horizontal" ? "x" : "y"));
        if (intersections) {
            const firstIntersection = intersections[0];
            closestIntersection ? pointDist(rayOrigin, firstIntersection) < pointDist(rayOrigin, closestIntersection) && (closestIntersection = firstIntersection, closestRect = target) : (closestIntersection = firstIntersection, closestRect = target);
        }
    }
    return closestRect || null;
}
function scaleRect(rect, scale, origin) {
    const { x, y, w, h } = rect, { x: originX, y: originY } = origin, newX = originX + (x - originX) * scale, newY = originY + (y - originY) * scale, newWidth = w * scale, newHeight = h * scale;
    return {
        x: newX,
        y: newY,
        w: newWidth,
        h: newHeight
    };
}
function getRectGroupXExtent(rects) {
    const minGroupX = Math.max(0, Math.min(...rects.map((r)=>r.x))), maxGroupX = Math.min(document.body.offsetWidth, Math.max(...rects.map((r)=>r.x + r.w)));
    return {
        min: minGroupX,
        max: maxGroupX,
        width: maxGroupX - minGroupX
    };
}
function getRectGroupYExtent(rects) {
    const minGroupY = Math.max(0, Math.min(...rects.map((r)=>r.y))), maxGroupY = Math.min(document.body.scrollHeight, Math.max(...rects.map((r)=>r.y + r.h)));
    return {
        min: minGroupY,
        max: maxGroupY,
        height: maxGroupY - minGroupY
    };
}
function calcTargetFlow(targets) {
    return targets.some((t1)=>targets.filter((t2)=>!rectEqual(t1, t2)).some((t2)=>t1.y === t2.y)) ? "horizontal" : "vertical";
}
function calcInsertPosition(origin, targets, flow) {
    if (flow === "horizontal") {
        const rayLeft = {
            x1: origin.x,
            y1: origin.y,
            x2: origin.x - 1e8,
            y2: origin.y
        }, rayRight = {
            x1: origin.x,
            y1: origin.y,
            x2: origin.x + 1e8,
            y2: origin.y
        };
        return {
            left: findClosestIntersection(rayLeft, targets, flow),
            right: findClosestIntersection(rayRight, targets, flow)
        };
    } else {
        const rayTop = {
            x1: origin.x,
            y1: origin.y,
            x2: origin.x,
            y2: origin.y - 1e8
        }, rayBottom = {
            x1: origin.x,
            y1: origin.y,
            x2: origin.x,
            y2: origin.y + 1e8
        };
        return {
            top: findClosestIntersection(rayTop, targets, flow),
            bottom: findClosestIntersection(rayBottom, targets, flow)
        };
    }
}
function findRectSanityData(rect, overlayGroup) {
    return overlayGroup.find((e)=>rectEqual(getRect(e.elements.element), rect))?.sanity;
}
function resolveInsertPosition(overlayGroup, insertPosition, flow) {
    return Object.values(insertPosition).every((v)=>v === null) ? null : flow === "horizontal" ? {
        left: insertPosition.left ? {
            rect: insertPosition.left,
            sanity: findRectSanityData(insertPosition.left, overlayGroup)
        } : null,
        right: insertPosition.right ? {
            rect: insertPosition.right,
            sanity: findRectSanityData(insertPosition.right, overlayGroup)
        } : null
    } : {
        top: insertPosition.top ? {
            rect: insertPosition.top,
            sanity: findRectSanityData(insertPosition.top, overlayGroup)
        } : null,
        bottom: insertPosition.bottom ? {
            rect: insertPosition.bottom,
            sanity: findRectSanityData(insertPosition.bottom, overlayGroup)
        } : null
    };
}
function calcMousePos(e) {
    const bodyBounds = document.body.getBoundingClientRect();
    return {
        x: Math.max(bodyBounds.x, Math.min(e.clientX, bodyBounds.x + bodyBounds.width)),
        y: e.clientY + window.scrollY
    };
}
function calcMousePosInverseTransform(mousePos2) {
    const body = document.body, transform = window.getComputedStyle(body).transform;
    if (transform === "none") return {
        x: mousePos2.x,
        y: mousePos2.y
    };
    const inverseMatrix = new DOMMatrix(transform).inverse(), transformedPoint = new DOMPoint(mousePos2.x, mousePos2.y).matrixTransform(inverseMatrix);
    return {
        x: transformedPoint.x,
        y: transformedPoint.y
    };
}
function buildPreviewSkeleton(mousePos2, element, scaleFactor) {
    const bounds = getRect(element), children = [
        ...element.querySelectorAll(":where(h1, h2, h3, h4, p, a, img, span, button):not(:has(*))")
    ];
    mousePos2.x <= bounds.x && (mousePos2.x = bounds.x), mousePos2.x >= bounds.x + bounds.w && (mousePos2.x = bounds.x + bounds.w), mousePos2.y >= bounds.y + bounds.h && (mousePos2.y = bounds.y + bounds.h), mousePos2.y <= bounds.y && (mousePos2.y = bounds.y);
    const childRects = children.map((child)=>{
        const rect = scaleRect(getRect(child), scaleFactor, {
            x: bounds.x,
            y: bounds.y
        });
        return {
            x: rect.x - bounds.x,
            y: rect.y - bounds.y,
            w: rect.w,
            h: rect.h,
            tagName: child.tagName
        };
    });
    return {
        offsetX: (bounds.x - mousePos2.x) * scaleFactor,
        offsetY: (bounds.y - mousePos2.y) * scaleFactor,
        w: bounds.w * scaleFactor,
        h: bounds.h * scaleFactor,
        maxWidth: bounds.w * scaleFactor * 0.75,
        childRects
    };
}
const minDragDelta = 4;
async function applyMinimapWrapperTransform(target, scaleFactor, minYScaled, handler, rectUpdateFrequency) {
    return new Promise((resolve)=>{
        target.addEventListener("transitionend", ()=>{
            setTimeout(()=>{
                handler({
                    type: "overlay/dragEndMinimapTransition"
                });
            }, rectUpdateFrequency * 2), resolve();
        }, {
            once: !0
        }), handler({
            type: "overlay/dragStartMinimapTransition"
        }), handler({
            type: "overlay/dragToggleMinimap",
            display: !0
        }), document.body.style.overflow = "hidden", document.body.style.height = "100%", document.documentElement.style.overflow = "initial", document.documentElement.style.height = "100%", setTimeout(()=>{
            target.style.transformOrigin = "50% 0px", target.style.transition = "transform 150ms ease", target.style.transform = `translate3d(0px, ${-minYScaled + scrollY}px, 0px) scale(${scaleFactor})`;
        }, 25);
    });
}
function calcMinimapTransformValues(rects, groupHeightOverride) {
    let groupHeight = groupHeightOverride || getRectGroupYExtent(rects).height;
    const padding = 100;
    groupHeight += padding * 2;
    const scaleFactor = groupHeight > window.innerHeight ? window.innerHeight / groupHeight : 1, scaledRects = rects.map((r)=>scaleRect(r, scaleFactor, {
            x: window.innerWidth / 2,
            y: 0
        })), { min: minYScaled } = getRectGroupYExtent(scaledRects);
    return {
        scaleFactor,
        minYScaled: minYScaled - padding * scaleFactor
    };
}
function calcGroupBoundsPreview(rects) {
    const groupBoundsX = getRectGroupXExtent(rects), groupBoundsY = getRectGroupYExtent(rects), offsetDist = 8, canOffsetX = groupBoundsX.min > offsetDist && groupBoundsX.min + groupBoundsX.width <= window.innerWidth - offsetDist, canOffsetY = groupBoundsY.min > offsetDist && groupBoundsY.min + groupBoundsY.height <= document.body.scrollHeight - offsetDist, canOffset = canOffsetX && canOffsetY;
    return {
        x: canOffset ? groupBoundsX.min - offsetDist : groupBoundsX.min,
        y: canOffset ? groupBoundsY.min - offsetDist : groupBoundsY.min,
        w: canOffset ? groupBoundsX.width + offsetDist * 2 : groupBoundsX.width,
        h: canOffset ? groupBoundsY.height + offsetDist * 2 : groupBoundsY.height
    };
}
async function resetMinimapWrapperTransform(endYOrigin, target, prescaleHeight2, handler, rectUpdateFrequency, previousRootStyleValues2) {
    return new Promise((resolve)=>{
        const transform = window.getComputedStyle(target).transform;
        if (new DOMMatrix(transform).a === 1) return;
        const maxScroll = prescaleHeight2 - window.innerHeight, prevScrollY = scrollY;
        endYOrigin -= window.innerHeight / 2, endYOrigin < 0 && (endYOrigin = 0), target.addEventListener("transitionend", ()=>{
            target.style.transition = "none", target.style.transform = "none", scrollTo({
                top: endYOrigin,
                behavior: "instant"
            }), setTimeout(()=>{
                handler({
                    type: "overlay/dragEndMinimapTransition"
                }), handler({
                    type: "overlay/dragToggleMinimap",
                    display: !1
                });
            }, rectUpdateFrequency * 2), resolve();
        }, {
            once: !0
        }), handler({
            type: "overlay/dragStartMinimapTransition"
        }), target.style.transform = `translateY(${Math.max(prevScrollY - endYOrigin, -maxScroll + prevScrollY)}px) scale(1)`, previousRootStyleValues2 && (document.body.style.overflow = previousRootStyleValues2.body.overflow, document.body.style.height = previousRootStyleValues2.body.height, document.documentElement.style.overflow = previousRootStyleValues2.documentElement.overflow, document.documentElement.style.height = previousRootStyleValues2.documentElement.height);
    });
}
let minimapScaleApplied = !1, mousePosInverseTransform = {
    y: 0
}, mousePos = {
    x: 0,
    y: 0
}, prescaleHeight = typeof document > "u" ? 0 : document.documentElement.scrollHeight, previousRootStyleValues = null;
function handleOverlayDrag(opts) {
    const { mouseEvent, element, overlayGroup, handler, target, onSequenceStart, onSequenceEnd } = opts;
    if (mouseEvent.button !== 0) return;
    window.focus();
    const rectUpdateFrequency = 150;
    let rects = overlayGroup.map((e)=>getRect(e.elements.element));
    const flow = element.getAttribute("data-sanity-drag-flow") || calcTargetFlow(rects), dragGroup = element.getAttribute("data-sanity-drag-group"), disableMinimap = !!element.getAttribute("data-sanity-drag-minimap-disable"), preventInsertDefault = !!element.getAttribute("data-sanity-drag-prevent-default"), documentHeightOverride = element.getAttribute("data-unstable_sanity-drag-document-height"), groupHeightOverride = element.getAttribute("data-unstable_sanity-drag-group-height");
    let insertPosition = null;
    const initialMousePos = calcMousePos(mouseEvent), scaleTarget = document.body, { minYScaled, scaleFactor } = calcMinimapTransformValues(rects, groupHeightOverride ? ~~groupHeightOverride : null);
    let sequenceStarted = !1, minimapPromptShown = !1, mousedown = !0;
    minimapScaleApplied || (previousRootStyleValues = {
        body: {
            overflow: window.getComputedStyle(document.body).overflow,
            height: window.getComputedStyle(document.body).height
        },
        documentElement: {
            overflow: window.getComputedStyle(document.documentElement).overflow,
            height: window.getComputedStyle(document.documentElement).height
        }
    }, prescaleHeight = documentHeightOverride ? ~~documentHeightOverride : document.documentElement.scrollHeight);
    const rectsInterval = setInterval(()=>{
        rects = overlayGroup.map((e)=>getRect(e.elements.element));
    }, rectUpdateFrequency), applyMinimap = ()=>{
        if (scaleFactor >= 1) return;
        const skeleton = buildPreviewSkeleton(mousePos, element, scaleFactor);
        handler({
            type: "overlay/dragUpdateSkeleton",
            skeleton
        }), handler({
            type: "overlay/dragToggleMinimapPrompt",
            display: !1
        }), applyMinimapWrapperTransform(scaleTarget, scaleFactor, minYScaled, handler, rectUpdateFrequency).then(()=>{
            setTimeout(()=>{
                handler({
                    type: "overlay/dragUpdateGroupRect",
                    groupRect: calcGroupBoundsPreview(rects)
                });
            }, rectUpdateFrequency * 2);
        });
    }, handleScroll = (e)=>{
        Math.abs(e.deltaY) >= 10 && scaleFactor < 1 && !minimapScaleApplied && !minimapPromptShown && !disableMinimap && mousedown && (handler({
            type: "overlay/dragToggleMinimapPrompt",
            display: !0
        }), minimapPromptShown = !0), e.shiftKey && !minimapScaleApplied && !disableMinimap && (window.dispatchEvent(new CustomEvent("unstable_sanity/dragApplyMinimap")), minimapScaleApplied = !0, setTimeout(()=>{
            applyMinimap();
        }, 50));
    }, handleMouseMove = (e)=>{
        if (e.preventDefault(), mousePos = calcMousePos(e), mousePosInverseTransform = calcMousePosInverseTransform(mousePos), Math.abs(pointDist(mousePos, initialMousePos)) < minDragDelta) return;
        if (!sequenceStarted) {
            const groupRect = calcGroupBoundsPreview(rects), skeleton = buildPreviewSkeleton(mousePos, element, 1);
            handler({
                type: "overlay/dragStart",
                flow
            }), handler({
                type: "overlay/dragUpdateSkeleton",
                skeleton
            }), handler({
                type: "overlay/dragUpdateGroupRect",
                groupRect
            }), sequenceStarted = !0, onSequenceStart();
        }
        handler({
            type: "overlay/dragUpdateCursorPosition",
            x: mousePos.x,
            y: mousePos.y
        }), e.shiftKey && !minimapScaleApplied && !disableMinimap && (window.dispatchEvent(new CustomEvent("unstable_sanity/dragApplyMinimap")), minimapScaleApplied = !0, setTimeout(()=>{
            applyMinimap();
        }, 50));
        const newInsertPosition = calcInsertPosition(mousePos, rects, flow);
        JSON.stringify(insertPosition) !== JSON.stringify(newInsertPosition) && (insertPosition = newInsertPosition, handler({
            type: "overlay/dragUpdateInsertPosition",
            insertPosition: resolveInsertPosition(overlayGroup, insertPosition, flow)
        }));
    }, handleMouseUp = ()=>{
        mousedown = !1, handler({
            type: "overlay/dragEnd",
            target,
            insertPosition: insertPosition ? resolveInsertPosition(overlayGroup, insertPosition, flow) : null,
            dragGroup,
            flow,
            preventInsertDefault
        }), minimapPromptShown && handler({
            type: "overlay/dragToggleMinimapPrompt",
            display: !1
        }), minimapScaleApplied || (clearInterval(rectsInterval), onSequenceEnd(), removeFrameListeners(), removeKeyListeners()), removeMouseListeners();
    }, handleKeyup = (e)=>{
        if (e.key === "Shift" && minimapScaleApplied) {
            minimapScaleApplied = !1;
            const skeleton = buildPreviewSkeleton(mousePos, element, 1 / scaleFactor);
            handler({
                type: "overlay/dragUpdateSkeleton",
                skeleton
            }), window.dispatchEvent(new CustomEvent("unstable_sanity/dragResetMinimap")), setTimeout(()=>{
                resetMinimapWrapperTransform(mousePosInverseTransform.y, scaleTarget, prescaleHeight, handler, rectUpdateFrequency, previousRootStyleValues);
            }, 50), handler({
                type: "overlay/dragUpdateGroupRect",
                groupRect: null
            }), mousedown || (clearInterval(rectsInterval), removeMouseListeners(), removeFrameListeners(), removeKeyListeners(), onSequenceEnd());
        }
    }, handleBlur = ()=>{
        handler({
            type: "overlay/dragUpdateGroupRect",
            groupRect: null
        }), window.dispatchEvent(new CustomEvent("unstable_sanity/dragResetMinimap")), setTimeout(()=>{
            resetMinimapWrapperTransform(mousePosInverseTransform.y, scaleTarget, prescaleHeight, handler, rectUpdateFrequency, previousRootStyleValues).then(()=>{
                minimapScaleApplied = !1;
            });
        }, 50), clearInterval(rectsInterval), removeMouseListeners(), removeFrameListeners(), removeKeyListeners(), onSequenceEnd();
    }, removeMouseListeners = ()=>{
        window.removeEventListener("mousemove", handleMouseMove), window.removeEventListener("wheel", handleScroll), window.removeEventListener("mouseup", handleMouseUp);
    }, removeKeyListeners = ()=>{
        window.removeEventListener("keyup", handleKeyup);
    }, removeFrameListeners = ()=>{
        window.removeEventListener("blur", handleBlur);
    };
    window.addEventListener("blur", handleBlur), window.addEventListener("keyup", handleKeyup), window.addEventListener("wheel", handleScroll), window.addEventListener("mousemove", handleMouseMove), window.addEventListener("mouseup", handleMouseUp);
}
const isElementNode$1 = (target)=>target instanceof HTMLElement || target instanceof SVGElement;
function findNonInlineElement(element) {
    const { display } = window.getComputedStyle(element);
    if (display !== "inline") return element;
    const parent = element.parentElement;
    return parent ? findNonInlineElement(parent) : null;
}
const findOverlayElement = (el)=>!el || !isElementNode$1(el) ? null : el.dataset?.sanityOverlayElement ? el : findOverlayElement(el.parentElement);
function testVercelStegaRegex(input) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vercel$2f$stega$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VERCEL_STEGA_REGEX"].lastIndex = 0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vercel$2f$stega$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VERCEL_STEGA_REGEX"].test(input);
}
function decodeStega(str, isAltText = !1) {
    try {
        const decoded = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vercel$2f$stega$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["vercelStegaDecode"])(str);
        return !decoded || decoded.origin !== "sanity.io" ? null : (isAltText && (decoded.href = decoded.href?.replace(".alt", "")), decoded);
    } catch (err) {
        return console.error("Failed to decode stega for string: ", str, "with the original error: ", err), null;
    }
}
function testAndDecodeStega(str, isAltText = !1) {
    return testVercelStegaRegex(str) ? decodeStega(str, isAltText) : null;
}
const isElementNode = (node)=>node.nodeType === Node.ELEMENT_NODE, isImgElement = (el)=>el.tagName === "IMG", isTimeElement = (el)=>el.tagName === "TIME", isSvgRootElement = (el)=>el.tagName.toUpperCase() === "SVG";
function isSanityNode(node) {
    return "path" in node;
}
function findCommonPath(first, second) {
    let firstParts = first.split("."), secondParts = second.split(".");
    const maxLength = Math.min(firstParts.length, secondParts.length);
    return firstParts = firstParts.slice(0, maxLength).reverse(), secondParts = secondParts.slice(0, maxLength).reverse(), firstParts.reduce((parts, part, i)=>part === secondParts[i] ? [
            ...parts,
            part
        ] : [], []).reverse().join(".");
}
function findCommonSanityData(nodes) {
    if (!nodes.length || !nodes.map((n)=>isSanityNode(n)).every((n, _i, arr)=>n === arr[0])) return;
    if (!isSanityNode(nodes[0])) return nodes[0];
    const sanityNodes = nodes.filter(isSanityNode);
    let common = nodes[0];
    const consistentValueKeys = [
        "projectId",
        "dataset",
        "id",
        "baseUrl",
        "workspace",
        "tool"
    ];
    for(let i = 1; i < sanityNodes.length; i++){
        const node = sanityNodes[i];
        if (consistentValueKeys.some((key)=>node[key] !== common?.[key])) {
            common = void 0;
            break;
        }
        common.path = findCommonPath(common.path, node.path);
    }
    return common;
}
function findSanityNodes(el) {
    const elements = [];
    function addElement(element, data) {
        const sanity = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$visual$2d$editing$2d$csm$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeSanityNodeData"])(data);
        if (!sanity) return;
        const measureElement = findNonInlineElement(element);
        measureElement && elements.push({
            elements: {
                element,
                measureElement
            },
            sanity
        });
    }
    if (el) for (const node of el.childNodes){
        const { nodeType, parentElement, textContent } = node;
        if (isElementNode(node) && node.dataset?.sanityEditTarget !== void 0) {
            const nodesInTarget = findSanityNodes(node).map(({ sanity })=>sanity);
            if (!nodesInTarget.map((n)=>isSanityNode(n)).every((n, _i, arr)=>n === arr[0])) continue;
            const commonData = findCommonSanityData(nodesInTarget);
            commonData && elements.push({
                elements: {
                    element: node,
                    measureElement: node
                },
                sanity: commonData
            });
        } else if (nodeType === Node.TEXT_NODE && parentElement && textContent) {
            const data = testAndDecodeStega(textContent);
            if (!data) continue;
            addElement(parentElement, data);
        } else if (isElementNode(node)) {
            if (node.tagName === "SCRIPT" || node.tagName === "SANITY-VISUAL-EDITING") continue;
            if (node.dataset?.sanity) addElement(node, node.dataset.sanity);
            else if (node.dataset?.sanityEditInfo) addElement(node, node.dataset.sanityEditInfo);
            else if (isImgElement(node)) {
                const data = testAndDecodeStega(node.alt, !0);
                if (!data) continue;
                addElement(node, data);
                continue;
            } else if (isTimeElement(node)) {
                const data = testAndDecodeStega(node.dateTime, !0);
                if (!data) continue;
                addElement(node, data);
            } else if (isSvgRootElement(node)) {
                if (!node.ariaLabel) continue;
                const data = testAndDecodeStega(node.ariaLabel, !0);
                if (!data) continue;
                addElement(node, data);
            }
            elements.push(...findSanityNodes(node));
        }
    }
    return elements;
}
function isSanityArrayPath(path) {
    const lastDotIndex = path.lastIndexOf(".");
    return path.substring(lastDotIndex, path.length).includes("[");
}
function getSanityNodeArrayPath(path) {
    if (!isSanityArrayPath(path)) return null;
    const split = path.split(".");
    return split[split.length - 1] = split[split.length - 1].replace(/\[.*?\]/g, "[]"), split.join(".");
}
function sanityNodesExistInSameArray(sanityNode1, sanityNode2) {
    return !isSanityArrayPath(sanityNode1.path) || !isSanityArrayPath(sanityNode2.path) ? !1 : getSanityNodeArrayPath(sanityNode1.path) === getSanityNodeArrayPath(sanityNode2.path);
}
function resolveDragAndDropGroup(element, sanity, elementSet, elementsMap) {
    if (!element.getAttribute("data-sanity") || element.getAttribute("data-sanity-drag-disable") || !sanity || !isSanityNode(sanity) || !isSanityArrayPath(sanity.path)) return null;
    const targetDragGroup = element.getAttribute("data-sanity-drag-group"), group = [
        ...elementSet
    ].reduce((acc, el)=>{
        const elData = elementsMap.get(el), elDragDisabled = el.getAttribute("data-sanity-drag-disable"), elDragGroup = el.getAttribute("data-sanity-drag-group"), elHasSanityAttribution = el.getAttribute("data-sanity") !== null, sharedDragGroup = targetDragGroup !== null ? targetDragGroup === elDragGroup : !0;
        return elData && !elDragDisabled && isSanityNode(elData.sanity) && sanityNodesExistInSameArray(sanity, elData.sanity) && sharedDragGroup && elHasSanityAttribution && acc.push(elData), acc;
    }, []);
    return group.length <= 1 ? null : group;
}
function createOverlayController({ handler, overlayElement, inFrame, inPopUp, optimisticActorReady }) {
    let activated = !1;
    const elementIdMap = /* @__PURE__ */ new Map(), elementsMap = /* @__PURE__ */ new WeakMap(), elementSet = /* @__PURE__ */ new Set(), measureElements = /* @__PURE__ */ new WeakMap(), cursorMap = /* @__PURE__ */ new WeakMap();
    let ro, io, mo, activeDragSequence = !1, hoverStack = [];
    const getHoveredElement = ()=>hoverStack[hoverStack.length - 1];
    function addEventHandlers(el, handlers) {
        el.addEventListener("click", handlers.click, {
            capture: !0
        }), el.addEventListener("contextmenu", handlers.contextmenu, {
            capture: !0
        }), el.addEventListener("mousemove", handlers.mousemove, {
            once: !0,
            capture: !0
        }), el.addEventListener("mousedown", handlers.mousedown, {
            capture: !0
        });
    }
    function removeEventHandlers(el, handlers) {
        el.removeEventListener("click", handlers.click, {
            capture: !0
        }), el.removeEventListener("contextmenu", handlers.contextmenu, {
            capture: !0
        }), el.removeEventListener("mousemove", handlers.mousemove, {
            capture: !0
        }), el.removeEventListener("mousedown", handlers.mousedown, {
            capture: !0
        }), el.removeEventListener("mouseenter", handlers.mouseenter), el.removeEventListener("mouseleave", handlers.mouseleave);
    }
    function activateElement({ id, elements, handlers }) {
        const { element, measureElement } = elements;
        addEventHandlers(element, handlers), ro.observe(measureElement), handler({
            type: "element/activate",
            id
        });
    }
    function deactivateElement({ id, elements, handlers }) {
        const { element, measureElement } = elements;
        removeEventHandlers(element, handlers), ro.unobserve(measureElement), hoverStack = hoverStack.filter((el)=>el !== element), handler({
            type: "element/deactivate",
            id
        });
    }
    function setOverlayCursor(element) {
        if (!(!inFrame && !inPopUp || !optimisticActorReady)) for (const hoverstackElement of hoverStack){
            if (element === hoverstackElement) {
                const targetSanityData = elementsMap.get(element)?.sanity;
                if (!targetSanityData || !isSanityNode(targetSanityData)) return;
                if (resolveDragAndDropGroup(element, targetSanityData, elementSet, elementsMap)) {
                    const existingCursor = element.style.cursor;
                    existingCursor && cursorMap.set(element, existingCursor), handler({
                        type: "overlay/setCursor",
                        element,
                        cursor: "move"
                    });
                    continue;
                }
            }
            restoreOverlayCursor(hoverstackElement);
        }
    }
    function restoreOverlayCursor(element) {
        const previousCursor = cursorMap.get(element);
        handler({
            type: "overlay/setCursor",
            element,
            cursor: previousCursor
        });
    }
    function registerElement({ elements, sanity }) {
        const { element, measureElement } = elements, eventHandlers = {
            click (event) {
                const target = event.target;
                if (element === getHoveredElement() && element.contains(target)) {
                    inFrame && (event.preventDefault(), event.stopPropagation());
                    const sanity2 = elementsMap.get(element)?.sanity;
                    sanity2 && !activeDragSequence && handler({
                        type: "element/click",
                        id,
                        sanity: sanity2
                    });
                }
            },
            contextmenu (event) {
                if (!("path" in sanity) || !inFrame && !inPopUp || !optimisticActorReady || !sanity.path.split(".").pop()?.includes("[_key==")) return;
                const target = event.target;
                element === getHoveredElement() && element.contains(target) && ((inFrame || inPopUp) && (event.preventDefault(), event.stopPropagation()), handler({
                    type: "element/contextmenu",
                    id,
                    position: {
                        x: event.clientX,
                        y: event.clientY
                    },
                    sanity
                }));
            },
            mousedown (event) {
                if (event.preventDefault(), event.currentTarget !== hoverStack.at(-1) || element.getAttribute("data-sanity-drag-disable") || !inFrame && !inPopUp || !optimisticActorReady) return;
                const targetSanityData = elementsMap.get(element)?.sanity;
                if (!targetSanityData || !isSanityNode(targetSanityData) || !isSanityArrayPath(targetSanityData.path)) return;
                const dragGroup = resolveDragAndDropGroup(element, sanity, elementSet, elementsMap);
                dragGroup && handleOverlayDrag({
                    element,
                    handler,
                    mouseEvent: event,
                    overlayGroup: dragGroup,
                    target: targetSanityData,
                    onSequenceStart: ()=>{
                        activeDragSequence = !0;
                    },
                    onSequenceEnd: ()=>{
                        setTimeout(()=>{
                            activeDragSequence = !1;
                        }, 250);
                    }
                });
            },
            mousemove (event) {
                eventHandlers.mouseenter(event);
                const el = event.currentTarget;
                el && (el.addEventListener("mouseenter", eventHandlers.mouseenter), el.addEventListener("mouseleave", eventHandlers.mouseleave));
            },
            mouseenter () {
                document.querySelector("vercel-live-feedback") && element.closest("[data-vercel-edit-info]") || element.closest("[data-vercel-edit-target]") || (hoverStack.push(element), handler({
                    type: "element/mouseenter",
                    id,
                    rect: getRect(element)
                }), setOverlayCursor(element));
            },
            mouseleave (e) {
                function leave() {
                    hoverStack.pop();
                    const hoveredElement = getHoveredElement();
                    if (handler({
                        type: "element/mouseleave",
                        id
                    }), hoveredElement) {
                        setOverlayCursor(hoveredElement);
                        const overlayElement2 = elementsMap.get(hoveredElement);
                        overlayElement2 && handler({
                            type: "element/mouseenter",
                            id: overlayElement2.id,
                            rect: getRect(hoveredElement)
                        });
                    }
                    restoreOverlayCursor(element);
                }
                function addDeferredLeave(el) {
                    const deferredLeave = (e2)=>{
                        const { relatedTarget: relatedTarget2 } = e2;
                        findOverlayElement(relatedTarget2) ? relatedTarget2 && isElementNode$1(relatedTarget2) && (el.removeEventListener("mouseleave", deferredLeave), addDeferredLeave(relatedTarget2)) : (el.removeEventListener("mouseleave", deferredLeave), leave());
                    };
                    el.addEventListener("mouseleave", deferredLeave);
                }
                const { relatedTarget } = e, container = findOverlayElement(relatedTarget), isInteractiveOverlayElement = overlayElement.contains(container);
                if (isElementNode$1(container) && isInteractiveOverlayElement) return addDeferredLeave(container);
                leave();
            }
        }, id = v4(), sanityNode = {
            id,
            elements,
            sanity,
            handlers: eventHandlers
        };
        elementSet.add(element), measureElements.set(measureElement, element), elementIdMap.set(id, element), elementsMap.set(element, sanityNode), io?.observe(element), handler({
            type: "element/register",
            id,
            element,
            rect: getRect(element),
            sanity,
            dragDisabled: !!element.getAttribute("data-sanity-drag-disable")
        }), activated && activateElement(sanityNode);
    }
    function updateElement({ elements, sanity }) {
        const { element } = elements, overlayElement2 = elementsMap.get(element);
        overlayElement2 && (elementsMap.set(element, {
            ...overlayElement2,
            sanity
        }), handler({
            type: "element/update",
            id: overlayElement2.id,
            rect: getRect(element),
            sanity
        }));
    }
    function parseElements(node) {
        const sanityNodes = findSanityNodes(node);
        for (const sanityNode of sanityNodes){
            const { element } = sanityNode.elements;
            elementsMap.has(element) ? updateElement(sanityNode) : registerElement(sanityNode);
        }
    }
    function unregisterElement(element) {
        const overlayElement2 = elementsMap.get(element);
        if (overlayElement2) {
            const { id, handlers } = overlayElement2;
            removeEventHandlers(element, handlers), ro.unobserve(element), elementsMap.delete(element), elementSet.delete(element), elementIdMap.delete(id), handler({
                type: "element/unregister",
                id
            });
        }
    }
    function handleMutation(mutations) {
        let mutationWasInScope = !1;
        for (const mutation of mutations){
            const { target, type } = mutation, node = type === "characterData" ? target.parentElement : target;
            node === overlayElement || overlayElement.contains(node) || (mutationWasInScope = !0, isElementNode$1(node) && parseElements({
                childNodes: [
                    node
                ]
            }));
        }
        if (mutationWasInScope) for (const element of elementSet)element.isConnected || unregisterElement(element);
    }
    function updateRect(el) {
        const overlayElement2 = elementsMap.get(el);
        overlayElement2 && handler({
            type: "element/updateRect",
            id: overlayElement2.id,
            rect: getRect(el)
        });
    }
    function handleResize(entries) {
        for (const entry of entries){
            const target = entry.target;
            if (isElementNode$1(target)) {
                const element = measureElements.get(target);
                if (!element) return;
                updateRect(element);
            }
        }
    }
    function handleIntersection(entries) {
        if (activated) for (const entry of entries){
            const { target } = entry, match = isElementNode$1(target) && elementsMap.get(target);
            match && (entry.isIntersecting ? activateElement(match) : deactivateElement(match));
        }
    }
    function handleBlur(event) {
        const element = findOverlayElement(event.target);
        if (element) {
            element.dataset.sanityOverlayElement === "capture" && (event.preventDefault(), event.stopPropagation());
            return;
        }
        hoverStack = [], handler({
            type: "overlay/blur"
        });
    }
    function handleWindowResize() {
        for (const element of elementSet)updateRect(element);
    }
    function handleKeydown(event) {
        event.key === "Escape" && (hoverStack = [], handler({
            type: "overlay/blur"
        }));
    }
    function handleWindowScroll(event) {
        const { target } = event;
        if (!(target === window.document || !isElementNode$1(target))) for (const element of elementSet)target.contains(element) && updateRect(element);
    }
    function activate() {
        activated || (io = new IntersectionObserver(handleIntersection, {
            threshold: 0.3
        }), elementSet.forEach((element)=>io.observe(element)), handler({
            type: "overlay/activate"
        }), activated = !0);
    }
    function deactivate() {
        activated && (io?.disconnect(), elementSet.forEach((element)=>{
            const overlayElement2 = elementsMap.get(element);
            overlayElement2 && deactivateElement(overlayElement2);
        }), handler({
            type: "overlay/deactivate"
        }), activated = !1);
    }
    function destroy() {
        window.removeEventListener("click", handleBlur), window.removeEventListener("contextmenu", handleBlur), window.removeEventListener("keydown", handleKeydown), window.removeEventListener("resize", handleWindowResize), window.removeEventListener("scroll", handleWindowScroll), mo.disconnect(), ro.disconnect(), elementSet.forEach((element)=>{
            unregisterElement(element);
        }), elementIdMap.clear(), elementSet.clear(), hoverStack = [], deactivate();
    }
    function create() {
        window.addEventListener("click", handleBlur), window.addEventListener("contextmenu", handleBlur), window.addEventListener("keydown", handleKeydown), window.addEventListener("resize", handleWindowResize), window.addEventListener("scroll", handleWindowScroll, {
            capture: !0,
            passive: !0
        }), ro = new ResizeObserver(handleResize), mo = new MutationObserver(handleMutation), mo.observe(document.body, {
            attributes: !0,
            characterData: !0,
            childList: !0,
            subtree: !0
        }), parseElements(document.body), activate();
    }
    return window.document.fonts.ready.then(()=>{
        for (const element of elementSet)updateRect(element);
    }), create(), {
        activate,
        deactivate,
        destroy
    };
}
const SharedStateContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(null);
;
 //# sourceMappingURL=SharedStateContext.js.map
}}),
"[project]/node_modules/@portabletext/toolkit/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "LIST_NEST_MODE_DIRECT": (()=>LIST_NEST_MODE_DIRECT),
    "LIST_NEST_MODE_HTML": (()=>LIST_NEST_MODE_HTML),
    "buildMarksTree": (()=>buildMarksTree),
    "isPortableTextBlock": (()=>isPortableTextBlock),
    "isPortableTextListItemBlock": (()=>isPortableTextListItemBlock),
    "isPortableTextSpan": (()=>isPortableTextSpan),
    "isPortableTextToolkitList": (()=>isPortableTextToolkitList),
    "isPortableTextToolkitSpan": (()=>isPortableTextToolkitSpan),
    "isPortableTextToolkitTextNode": (()=>isPortableTextToolkitTextNode),
    "nestLists": (()=>nestLists),
    "sortMarksByOccurences": (()=>sortMarksByOccurences),
    "spanToPlainText": (()=>spanToPlainText),
    "toPlainText": (()=>toPlainText)
});
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function isPortableTextSpan(node) {
    return node._type === "span" && "text" in node && typeof node.text == "string" && (typeof node.marks > "u" || Array.isArray(node.marks) && node.marks.every((mark)=>typeof mark == "string"));
}
function isPortableTextBlock(node) {
    return(// A block doesn't _have_ to be named 'block' - to differentiate between
    // allowed child types and marks, one might name them differently
    typeof node._type == "string" && // Toolkit-types like nested spans are @-prefixed
    node._type[0] !== "@" && (// `markDefs` isn't _required_ per say, but if it's there, it needs to be an array
    !("markDefs" in node) || !node.markDefs || Array.isArray(node.markDefs) && // Every mark definition needs to have an `_key` to be mappable in child spans
    node.markDefs.every((def)=>typeof def._key == "string")) && // `children` is required and needs to be an array
    "children" in node && Array.isArray(node.children) && // All children are objects with `_type` (usually spans, but can contain other stuff)
    node.children.every((child)=>typeof child == "object" && "_type" in child));
}
function isPortableTextListItemBlock(block) {
    return isPortableTextBlock(block) && "listItem" in block && typeof block.listItem == "string" && (typeof block.level > "u" || typeof block.level == "number");
}
function isPortableTextToolkitList(block) {
    return block._type === "@list";
}
function isPortableTextToolkitSpan(span) {
    return span._type === "@span";
}
function isPortableTextToolkitTextNode(node) {
    return node._type === "@text";
}
const knownDecorators = [
    "strong",
    "em",
    "code",
    "underline",
    "strike-through"
];
function sortMarksByOccurences(span, index, blockChildren) {
    if (!isPortableTextSpan(span) || !span.marks) return [];
    if (!span.marks.length) return [];
    const marks = span.marks.slice(), occurences = {};
    return marks.forEach((mark)=>{
        occurences[mark] = 1;
        for(let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++){
            const sibling = blockChildren[siblingIndex];
            if (sibling && isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) occurences[mark]++;
            else break;
        }
    }), marks.sort((markA, markB)=>sortMarks(occurences, markA, markB));
}
function sortMarks(occurences, markA, markB) {
    const aOccurences = occurences[markA], bOccurences = occurences[markB];
    if (aOccurences !== bOccurences) return bOccurences - aOccurences;
    const aKnownPos = knownDecorators.indexOf(markA), bKnownPos = knownDecorators.indexOf(markB);
    return aKnownPos !== bKnownPos ? aKnownPos - bKnownPos : markA.localeCompare(markB);
}
function buildMarksTree(block) {
    var _a, _b;
    const { children } = block, markDefs = (_a = block.markDefs) != null ? _a : [];
    if (!children || !children.length) return [];
    const sortedMarks = children.map(sortMarksByOccurences), rootNode = {
        _type: "@span",
        children: [],
        markType: "<unknown>"
    };
    let nodeStack = [
        rootNode
    ];
    for(let i = 0; i < children.length; i++){
        const span = children[i];
        if (!span) continue;
        const marksNeeded = sortedMarks[i] || [];
        let pos = 1;
        if (nodeStack.length > 1) for(pos; pos < nodeStack.length; pos++){
            const mark = ((_b = nodeStack[pos]) == null ? void 0 : _b.markKey) || "", index = marksNeeded.indexOf(mark);
            if (index === -1) break;
            marksNeeded.splice(index, 1);
        }
        nodeStack = nodeStack.slice(0, pos);
        let currentNode = nodeStack[nodeStack.length - 1];
        if (currentNode) {
            for (const markKey of marksNeeded){
                const markDef = markDefs == null ? void 0 : markDefs.find((def)=>def._key === markKey), markType = markDef ? markDef._type : markKey, node = {
                    _type: "@span",
                    _key: span._key,
                    children: [],
                    markDef,
                    markType,
                    markKey
                };
                currentNode.children.push(node), nodeStack.push(node), currentNode = node;
            }
            if (isPortableTextSpan(span)) {
                const lines = span.text.split(`
`);
                for(let line = lines.length; line-- > 1;)lines.splice(line, 0, `
`);
                currentNode.children = currentNode.children.concat(lines.map((text)=>({
                        _type: "@text",
                        text
                    })));
            } else currentNode.children = currentNode.children.concat(span);
        }
    }
    return rootNode.children;
}
function nestLists(blocks, mode) {
    const tree = [];
    let currentList;
    for(let i = 0; i < blocks.length; i++){
        const block = blocks[i];
        if (block) {
            if (!isPortableTextListItemBlock(block)) {
                tree.push(block), currentList = void 0;
                continue;
            }
            if (!currentList) {
                currentList = listFromBlock(block, i, mode), tree.push(currentList);
                continue;
            }
            if (blockMatchesList(block, currentList)) {
                currentList.children.push(block);
                continue;
            }
            if ((block.level || 1) > currentList.level) {
                const newList = listFromBlock(block, i, mode);
                if (mode === "html") {
                    const lastListItem = currentList.children[currentList.children.length - 1], newLastChild = _objectSpread(_objectSpread({}, lastListItem), {}, {
                        children: [
                            ...lastListItem.children,
                            newList
                        ]
                    });
                    currentList.children[currentList.children.length - 1] = newLastChild;
                } else currentList.children.push(newList);
                currentList = newList;
                continue;
            }
            if ((block.level || 1) < currentList.level) {
                const matchingBranch = tree[tree.length - 1], match = matchingBranch && findListMatching(matchingBranch, block);
                if (match) {
                    currentList = match, currentList.children.push(block);
                    continue;
                }
                currentList = listFromBlock(block, i, mode), tree.push(currentList);
                continue;
            }
            if (block.listItem !== currentList.listItem) {
                const matchingBranch = tree[tree.length - 1], match = matchingBranch && findListMatching(matchingBranch, {
                    level: block.level || 1
                });
                if (match && match.listItem === block.listItem) {
                    currentList = match, currentList.children.push(block);
                    continue;
                } else {
                    currentList = listFromBlock(block, i, mode), tree.push(currentList);
                    continue;
                }
            }
            console.warn("Unknown state encountered for block", block), tree.push(block);
        }
    }
    return tree;
}
function blockMatchesList(block, list) {
    return (block.level || 1) === list.level && block.listItem === list.listItem;
}
function listFromBlock(block, index, mode) {
    return {
        _type: "@list",
        _key: `${block._key || `${index}`}-parent`,
        mode,
        level: block.level || 1,
        listItem: block.listItem,
        children: [
            block
        ]
    };
}
function findListMatching(rootNode, matching) {
    const level = matching.level || 1, style = matching.listItem || "normal", filterOnType = typeof matching.listItem == "string";
    if (isPortableTextToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || "normal") === style) return rootNode;
    if (!("children" in rootNode)) return;
    const node = rootNode.children[rootNode.children.length - 1];
    return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;
}
function spanToPlainText(span) {
    let text = "";
    return span.children.forEach((current)=>{
        isPortableTextToolkitTextNode(current) ? text += current.text : isPortableTextToolkitSpan(current) && (text += spanToPlainText(current));
    }), text;
}
const leadingSpace = /^\s/, trailingSpace = /\s$/;
function toPlainText(block) {
    const blocks = Array.isArray(block) ? block : [
        block
    ];
    let text = "";
    return blocks.forEach((current, index)=>{
        if (!isPortableTextBlock(current)) return;
        let pad = !1;
        current.children.forEach((span)=>{
            isPortableTextSpan(span) ? (text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? " " : "", text += span.text, pad = !1) : pad = !0;
        }), index !== blocks.length - 1 && (text += `

`);
    }), text;
}
const LIST_NEST_MODE_HTML = "html", LIST_NEST_MODE_DIRECT = "direct";
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@portabletext/react/dist/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "PortableText": (()=>PortableText),
    "defaultComponents": (()=>defaultComponents),
    "mergeComponents": (()=>mergeComponents)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react-experimental/jsx-runtime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/toolkit/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react-experimental/index.js [app-client] (ecmascript)");
const _excluded = [
    "block",
    "list",
    "listItem",
    "marks",
    "types"
], _excluded2 = [
    "listItem"
], _excluded3 = [
    "_key"
];
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties(e, t) {
    if (null == e) return {};
    var o, r, i = _objectWithoutPropertiesLoose(e, t);
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(e);
        for(r = 0; r < s.length; r++)o = s[r], t.includes(o) || ({}).propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
}
function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for(var n in r)if (({}).hasOwnProperty.call(r, n)) {
        if (e.includes(n)) continue;
        t[n] = r[n];
    }
    return t;
}
;
;
;
;
const defaultLists = {
    number: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("ol", {
            children
        }),
    bullet: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("ul", {
            children
        })
}, DefaultListItem = ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("li", {
        children
    }), link = ({ children, value })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("a", {
        href: value?.href,
        children
    }), underlineStyle = {
    textDecoration: "underline"
}, defaultMarks = {
    em: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("em", {
            children
        }),
    strong: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("strong", {
            children
        }),
    code: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("code", {
            children
        }),
    underline: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("span", {
            style: underlineStyle,
            children
        }),
    "strike-through": ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("del", {
            children
        }),
    link
}, getTemplate = (type, prop)=>`[@portabletext/react] Unknown ${type}, specify a component for it in the \`components.${prop}\` prop`, unknownTypeWarning = (typeName)=>getTemplate(`block type "${typeName}"`, "types"), unknownMarkWarning = (markType)=>getTemplate(`mark type "${markType}"`, "marks"), unknownBlockStyleWarning = (blockStyle)=>getTemplate(`block style "${blockStyle}"`, "block"), unknownListStyleWarning = (listStyle)=>getTemplate(`list style "${listStyle}"`, "list"), unknownListItemStyleWarning = (listStyle)=>getTemplate(`list item style "${listStyle}"`, "listItem");
function printWarning(message) {
    console.warn(message);
}
const hidden = {
    display: "none"
}, DefaultUnknownType = ({ value, isInline })=>{
    const warning = unknownTypeWarning(value._type);
    return isInline ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("span", {
        style: hidden,
        children: warning
    }) : /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("div", {
        style: hidden,
        children: warning
    });
}, DefaultUnknownMark = ({ markType, children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("span", {
        className: `unknown__pt__mark__${markType}`,
        children
    }), DefaultUnknownBlockStyle = ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("p", {
        children
    }), DefaultUnknownList = ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("ul", {
        children
    }), DefaultUnknownListItem = ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("li", {
        children
    }), DefaultHardBreak = ()=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("br", {}), defaultBlockStyles = {
    normal: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("p", {
            children
        }),
    blockquote: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("blockquote", {
            children
        }),
    h1: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("h1", {
            children
        }),
    h2: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("h2", {
            children
        }),
    h3: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("h3", {
            children
        }),
    h4: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("h4", {
            children
        }),
    h5: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("h5", {
            children
        }),
    h6: ({ children })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("h6", {
            children
        })
}, defaultComponents = {
    types: {},
    block: defaultBlockStyles,
    marks: defaultMarks,
    list: defaultLists,
    listItem: DefaultListItem,
    hardBreak: DefaultHardBreak,
    unknownType: DefaultUnknownType,
    unknownMark: DefaultUnknownMark,
    unknownList: DefaultUnknownList,
    unknownListItem: DefaultUnknownListItem,
    unknownBlockStyle: DefaultUnknownBlockStyle
};
function mergeComponents(parent, overrides) {
    const { block, list, listItem, marks, types } = overrides, rest = _objectWithoutProperties(overrides, _excluded);
    return _objectSpread(_objectSpread({}, parent), {}, {
        block: mergeDeeply(parent, overrides, "block"),
        list: mergeDeeply(parent, overrides, "list"),
        listItem: mergeDeeply(parent, overrides, "listItem"),
        marks: mergeDeeply(parent, overrides, "marks"),
        types: mergeDeeply(parent, overrides, "types")
    }, rest);
}
function mergeDeeply(parent, overrides, key) {
    const override = overrides[key], parentVal = parent[key];
    return typeof override == "function" || override && typeof parentVal == "function" ? override : override ? _objectSpread(_objectSpread({}, parentVal), override) : parentVal;
}
function PortableText({ value: input, components: componentOverrides, listNestingMode, onMissingComponent: missingComponentHandler = printWarning }) {
    const handleMissingComponent = missingComponentHandler || noop, blocks = Array.isArray(input) ? input : [
        input
    ], nested = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nestLists"])(blocks, listNestingMode || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LIST_NEST_MODE_HTML"]), components = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "PortableText.useMemo[components]": ()=>componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents
    }["PortableText.useMemo[components]"], [
        componentOverrides
    ]), renderNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "PortableText.useMemo[renderNode]": ()=>getNodeRenderer(components, handleMissingComponent)
    }["PortableText.useMemo[renderNode]"], [
        components,
        handleMissingComponent
    ]), rendered = nested.map((node, index)=>renderNode({
            node,
            index,
            isInline: !1,
            renderNode
        }));
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], {
        children: rendered
    });
}
const getNodeRenderer = (components, handleMissingComponent)=>{
    function renderNode(options) {
        const { node, index, isInline } = options, key = node._key || `node-${index}`;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPortableTextToolkitList"])(node) ? renderList(node, index, key) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPortableTextListItemBlock"])(node) ? renderListItem(node, index, key) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPortableTextToolkitSpan"])(node) ? renderSpan(node, index, key) : hasCustomComponentForNode(node) ? renderCustomBlock(node, index, key, isInline) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPortableTextBlock"])(node) ? renderBlock(node, index, key, isInline) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPortableTextToolkitTextNode"])(node) ? renderText(node, key) : renderUnknownType(node, index, key, isInline);
    }
    function hasCustomComponentForNode(node) {
        return node._type in components.types;
    }
    function renderListItem(node, index, key) {
        const tree = serializeBlock({
            node,
            index,
            isInline: !1,
            renderNode
        }), renderer = components.listItem, Li = (typeof renderer == "function" ? renderer : renderer[node.listItem]) || components.unknownListItem;
        if (Li === components.unknownListItem) {
            const style = node.listItem || "bullet";
            handleMissingComponent(unknownListItemStyleWarning(style), {
                type: style,
                nodeType: "listItemStyle"
            });
        }
        let children = tree.children;
        if (node.style && node.style !== "normal") {
            const { listItem } = node, blockNode = _objectWithoutProperties(node, _excluded2);
            children = renderNode({
                node: blockNode,
                index,
                isInline: !1,
                renderNode
            });
        }
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(Li, {
            value: node,
            index,
            isInline: !1,
            renderNode,
            children
        }, key);
    }
    function renderList(node, index, key) {
        const children = node.children.map((child, childIndex)=>renderNode({
                node: child._key ? child : _objectSpread(_objectSpread({}, child), {}, {
                    _key: `li-${index}-${childIndex}`
                }),
                index: childIndex,
                isInline: !1,
                renderNode
            })), component = components.list, List = (typeof component == "function" ? component : component[node.listItem]) || components.unknownList;
        if (List === components.unknownList) {
            const style = node.listItem || "bullet";
            handleMissingComponent(unknownListStyleWarning(style), {
                nodeType: "listStyle",
                type: style
            });
        }
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(List, {
            value: node,
            index,
            isInline: !1,
            renderNode,
            children
        }, key);
    }
    function renderSpan(node, _index, key) {
        const { markDef, markType, markKey } = node, Span = components.marks[markType] || components.unknownMark, children = node.children.map((child, childIndex)=>renderNode({
                node: child,
                index: childIndex,
                isInline: !0,
                renderNode
            }));
        return Span === components.unknownMark && handleMissingComponent(unknownMarkWarning(markType), {
            nodeType: "mark",
            type: markType
        }), /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(Span, {
            text: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["spanToPlainText"])(node),
            value: markDef,
            markType,
            markKey,
            renderNode,
            children
        }, key);
    }
    function renderBlock(node, index, key, isInline) {
        const _serializeBlock = serializeBlock({
            node,
            index,
            isInline,
            renderNode
        }), { _key } = _serializeBlock, props = _objectWithoutProperties(_serializeBlock, _excluded3), style = props.node.style || "normal", Block = (typeof components.block == "function" ? components.block : components.block[style]) || components.unknownBlockStyle;
        return Block === components.unknownBlockStyle && handleMissingComponent(unknownBlockStyleWarning(style), {
            nodeType: "blockStyle",
            type: style
        }), /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(Block, _objectSpread(_objectSpread({}, props), {}, {
            value: props.node,
            renderNode
        }), key);
    }
    function renderText(node, key) {
        if (node.text === `
`) {
            const HardBreak = components.hardBreak;
            return HardBreak ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(HardBreak, {}, key) : `
`;
        }
        return node.text;
    }
    function renderUnknownType(node, index, key, isInline) {
        const nodeOptions = {
            value: node,
            isInline,
            index,
            renderNode
        };
        handleMissingComponent(unknownTypeWarning(node._type), {
            nodeType: "block",
            type: node._type
        });
        const UnknownType = components.unknownType;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(UnknownType, _objectSpread({}, nodeOptions), key);
    }
    function renderCustomBlock(node, index, key, isInline) {
        const nodeOptions = {
            value: node,
            isInline,
            index,
            renderNode
        }, Node = components.types[node._type];
        return Node ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$experimental$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(Node, _objectSpread({}, nodeOptions), key) : null;
    }
    return renderNode;
};
function serializeBlock(options) {
    const { node, index, isInline, renderNode } = options, children = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["buildMarksTree"])(node).map((child, i)=>renderNode({
            node: child,
            isInline: !0,
            index: i,
            renderNode
        }));
    return {
        _key: node._key || `block-${index}`,
        children,
        index,
        isInline,
        node
    };
}
function noop() {}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/slugify/slugify.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
;
(function(name, root, factory) {
    if ("TURBOPACK compile-time truthy", 1) {
        module.exports = factory();
        module.exports['default'] = factory();
    } else {
        "TURBOPACK unreachable";
    }
})('slugify', this, function() {
    var charMap = JSON.parse('{"$":"dollar","%":"percent","&":"and","<":"less",">":"greater","|":"or","":"cent","":"pound","":"currency","":"yen","":"(c)","":"a","":"(r)","":"o","":"A","":"A","":"A","":"A","":"A","":"A","":"AE","":"C","":"E","":"E","":"E","":"E","":"I","":"I","":"I","":"I","":"D","":"N","":"O","":"O","":"O","":"O","":"O","":"O","":"U","":"U","":"U","":"U","":"Y","":"TH","":"ss","":"a","":"a","":"a","":"a","":"a","":"a","":"ae","":"c","":"e","":"e","":"e","":"e","":"i","":"i","":"i","":"i","":"d","":"n","":"o","":"o","":"o","":"o","":"o","":"o","":"u","":"u","":"u","":"u","":"y","":"th","":"y","":"A","":"a","":"A","":"a","":"A","":"a","":"C","":"c","":"C","":"c","":"D","":"d","":"DJ","":"dj","":"E","":"e","":"E","":"e","":"e","":"e","":"E","":"e","":"G","":"g","":"G","":"g","":"I","":"i","":"i","":"i","":"I","":"i","":"I","":"i","":"k","":"k","":"L","":"l","":"L","":"l","":"L","":"l","":"N","":"n","":"N","":"n","":"N","":"n","":"O","":"o","":"O","":"o","":"OE","":"oe","":"R","":"r","":"R","":"r","":"S","":"s","":"S","":"s","":"S","":"s","":"T","":"t","":"T","":"t","":"U","":"u","":"u","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"W","":"w","":"Y","":"y","":"Y","":"Z","":"z","":"Z","":"z","":"Z","":"z","":"E","":"f","":"O","":"o","":"U","":"u","":"LJ","":"lj","":"NJ","":"nj","":"S","":"s","":"T","":"t","":"e","":"o","":"A","":"E","":"H","":"I","":"O","":"Y","":"W","":"i","":"A","":"B","":"G","":"D","":"E","":"Z","":"H","":"8","":"I","":"K","":"L","":"M","":"N","":"3","":"O","":"P","":"R","":"S","":"T","":"Y","":"F","":"X","":"PS","":"W","":"I","":"Y","":"a","":"e","":"h","":"i","":"y","":"a","":"b","":"g","":"d","":"e","":"z","":"h","":"8","":"i","":"k","":"l","":"m","":"n","":"3","":"o","":"p","":"r","":"s","":"s","":"t","":"y","":"f","":"x","":"ps","":"w","":"i","":"y","":"o","":"y","":"w","":"Yo","":"DJ","":"Ye","":"I","":"Yi","":"J","":"LJ","":"NJ","":"C","":"DZ","":"A","":"B","":"V","":"G","":"D","":"E","":"Zh","":"Z","":"I","":"J","":"K","":"L","":"M","":"N","":"O","":"P","":"R","":"S","":"T","":"U","":"F","":"H","":"C","":"Ch","":"Sh","":"Sh","":"U","":"Y","":"","":"E","":"Yu","":"Ya","":"a","":"b","":"v","":"g","":"d","":"e","":"zh","":"z","":"i","":"j","":"k","":"l","":"m","":"n","":"o","":"p","":"r","":"s","":"t","":"u","":"f","":"h","":"c","":"ch","":"sh","":"sh","":"u","":"y","":"","":"e","":"yu","":"ya","":"yo","":"dj","":"ye","":"i","":"yi","":"j","":"lj","":"nj","":"c","":"u","":"dz","":"G","":"g","":"GH","":"gh","":"KH","":"kh","":"NG","":"ng","":"UE","":"ue","":"U","":"u","":"H","":"h","":"AE","":"ae","":"OE","":"oe","":"A","":"B","":"G","":"D","":"E","":"Z","":"E\'","":"Y\'","":"T\'","":"JH","":"I","":"L","":"X","":"C\'","":"K","":"H","":"D\'","":"GH","":"TW","":"M","":"Y","":"N","":"SH","":"CH","":"P","":"J","":"R\'","":"S","":"V","":"T","":"R","":"C","":"P\'","":"Q\'","":"O\'\'","":"F","":"EV","":"a","":"aa","":"a","":"u","":"i","":"e","":"a","":"b","":"h","":"t","":"th","":"j","":"h","":"kh","":"d","":"th","":"r","":"z","":"s","":"sh","":"s","":"dh","":"t","":"z","":"a","":"gh","":"f","":"q","":"k","":"l","":"m","":"n","":"h","":"w","":"a","":"y","":"an","":"on","":"en","":"a","":"u","":"e","":"","":"0","":"1","":"2","":"3","":"4","":"5","":"6","":"7","":"8","":"9","":"p","":"ch","":"zh","":"k","":"g","":"y","":"0","":"1","":"2","":"3","":"4","":"5","":"6","":"7","":"8","":"9","":"baht","":"a","":"b","":"g","":"d","":"e","":"v","":"z","":"t","":"i","":"k","":"l","":"m","":"n","":"o","":"p","":"zh","":"r","":"s","":"t","":"u","":"f","":"k","":"gh","":"q","":"sh","":"ch","":"ts","":"dz","":"ts","":"ch","":"kh","":"j","":"h","":"S","":"s","":"W","":"w","":"W","":"w","":"W","":"w","":"SS","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"I","":"i","":"I","":"i","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"Y","":"y","":"Y","":"y","":"Y","":"y","":"Y","":"y","":"-","":"\'","":"\'","":"\\\"","":"\\\"","":"\\\"","":"+","":"*","":"...","":"ecu","":"cruzeiro","":"french franc","":"lira","":"mill","":"naira","":"peseta","":"rupee","":"won","":"new shequel","":"dong","":"euro","":"kip","":"tugrik","":"drachma","":"penny","":"peso","":"guarani","":"austral","":"hryvnia","":"cedi","":"kazakhstani tenge","":"indian rupee","":"turkish lira","":"russian ruble","":"bitcoin","":"sm","":"tm","":"d","":"delta","":"sum","":"infinity","":"love","":"yuan","":"yen","":"rial","":"laa","":"laa","":"lai","":"la"}');
    var locales = JSON.parse('{"bg":{"":"Y","":"Ts","":"Sht","":"A","":"Y","":"y","":"ts","":"sht","":"a","":"y"},"de":{"":"AE","":"ae","":"OE","":"oe","":"UE","":"ue","":"ss","%":"prozent","&":"und","|":"oder","":"summe","":"unendlich","":"liebe"},"es":{"%":"por ciento","&":"y","<":"menor que",">":"mayor que","|":"o","":"centavos","":"libras","":"moneda","":"francos","":"suma","":"infinito","":"amor"},"fr":{"%":"pourcent","&":"et","<":"plus petit",">":"plus grand","|":"ou","":"centime","":"livre","":"devise","":"franc","":"somme","":"infini","":"amour"},"pt":{"%":"porcento","&":"e","<":"menor",">":"maior","|":"ou","":"centavo","":"soma","":"libra","":"infinito","":"amor"},"uk":{"":"Y","":"y","":"Y","":"y","":"Ts","":"ts","":"Kh","":"kh","":"Shch","":"shch","":"H","":"h"},"vi":{"":"D","":"d"},"da":{"":"OE","":"oe","":"AA","":"aa","%":"procent","&":"og","|":"eller","$":"dollar","<":"mindre end",">":"strre end"},"nb":{"&":"og","":"AA","":"AE","":"OE","":"aa","":"ae","":"oe"},"it":{"&":"e"},"nl":{"&":"en"},"sv":{"&":"och","":"AA","":"AE","":"OE","":"aa","":"ae","":"oe"}}');
    function replace(string, options) {
        if (typeof string !== 'string') {
            throw new Error('slugify: string argument expected');
        }
        options = typeof options === 'string' ? {
            replacement: options
        } : options || {};
        var locale = locales[options.locale] || {};
        var replacement = options.replacement === undefined ? '-' : options.replacement;
        var trim = options.trim === undefined ? true : options.trim;
        var slug = string.normalize().split('')// replace characters based on charMap
        .reduce(function(result, ch) {
            var appendChar = locale[ch];
            if (appendChar === undefined) appendChar = charMap[ch];
            if (appendChar === undefined) appendChar = ch;
            if (appendChar === replacement) appendChar = ' ';
            return result + appendChar// remove not allowed characters
            .replace(options.remove || /[^\w\s$*_+~.()'"!\-:@]+/g, '');
        }, '');
        if (options.strict) {
            slug = slug.replace(/[^A-Za-z0-9\s]/g, '');
        }
        if (trim) {
            slug = slug.trim();
        }
        // Replace spaces with replacement character, treating multiple consecutive
        // spaces as a single space.
        slug = slug.replace(/\s+/g, replacement);
        if (options.lower) {
            slug = slug.toLowerCase();
        }
        return slug;
    }
    replace.extend = function(customMap) {
        Object.assign(charMap, customMap);
    };
    return replace;
});
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/arrow-up-right.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @license lucide-react v0.479.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s({
    "__iconNode": (()=>__iconNode),
    "default": (()=>ArrowUpRight)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M7 7h10v10",
            key: "1tivn9"
        }
    ],
    [
        "path",
        {
            d: "M7 17 17 7",
            key: "1vkiza"
        }
    ]
];
const ArrowUpRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("ArrowUpRight", __iconNode);
;
 //# sourceMappingURL=arrow-up-right.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/arrow-up-right.js [app-client] (ecmascript) <export default as ArrowUpRight>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ArrowUpRight": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$arrow$2d$up$2d$right$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$arrow$2d$up$2d$right$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/arrow-up-right.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/chevron-right.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @license lucide-react v0.479.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s({
    "__iconNode": (()=>__iconNode),
    "default": (()=>ChevronRight)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "m9 18 6-6-6-6",
            key: "mthhwq"
        }
    ]
];
const ChevronRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("ChevronRight", __iconNode);
;
 //# sourceMappingURL=chevron-right.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/chevron-right.js [app-client] (ecmascript) <export default as ChevronRight>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ChevronRight": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$chevron$2d$right$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$chevron$2d$right$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/chevron-right.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/loader-circle.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @license lucide-react v0.479.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s({
    "__iconNode": (()=>__iconNode),
    "default": (()=>LoaderCircle)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const __iconNode = [
    [
        "path",
        {
            d: "M21 12a9 9 0 1 1-6.219-8.56",
            key: "13zald"
        }
    ]
];
const LoaderCircle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("LoaderCircle", __iconNode);
;
 //# sourceMappingURL=loader-circle.js.map
}}),
"[project]/node_modules/lucide-react/dist/esm/icons/loader-circle.js [app-client] (ecmascript) <export default as LoaderCircle>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "LoaderCircle": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$loader$2d$circle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$loader$2d$circle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/loader-circle.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/next/dist/client/form-shared.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    DISALLOWED_FORM_PROPS: null,
    checkFormActionUrl: null,
    createFormSubmitDestinationUrl: null,
    hasReactClientActionAttributes: null,
    hasUnsupportedSubmitterAttributes: null,
    isSupportedFormEncType: null,
    isSupportedFormMethod: null,
    isSupportedFormTarget: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DISALLOWED_FORM_PROPS: function() {
        return DISALLOWED_FORM_PROPS;
    },
    checkFormActionUrl: function() {
        return checkFormActionUrl;
    },
    createFormSubmitDestinationUrl: function() {
        return createFormSubmitDestinationUrl;
    },
    hasReactClientActionAttributes: function() {
        return hasReactClientActionAttributes;
    },
    hasUnsupportedSubmitterAttributes: function() {
        return hasUnsupportedSubmitterAttributes;
    },
    isSupportedFormEncType: function() {
        return isSupportedFormEncType;
    },
    isSupportedFormMethod: function() {
        return isSupportedFormMethod;
    },
    isSupportedFormTarget: function() {
        return isSupportedFormTarget;
    }
});
const DISALLOWED_FORM_PROPS = [
    'method',
    'encType',
    'target'
];
function createFormSubmitDestinationUrl(action, formElement) {
    let targetUrl;
    try {
        // NOTE: It might be more correct to resolve URLs relative to `document.baseURI`,
        // but we already do it relative to `location.href` elsewhere:
        //  (see e.g. https://github.com/vercel/next.js/blob/bb0e6722f87ceb2d43015f5b8a413d0072f2badf/packages/next/src/client/components/app-router.tsx#L146)
        // so it's better to stay consistent.
        const base = window.location.href;
        targetUrl = new URL(action, base);
    } catch (err) {
        throw Object.defineProperty(new Error('Cannot parse form action "' + action + '" as a URL', {
            cause: err
        }), "__NEXT_ERROR_CODE", {
            value: "E152",
            enumerable: false,
            configurable: true
        });
    }
    if (targetUrl.searchParams.size) {
        // url-encoded HTML forms *overwrite* any search params in the `action` url:
        //
        //  "Let `query` be the result of running the application/x-www-form-urlencoded serializer [...]"
        //  "Set parsed action's query component to `query`."
        //   https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#submit-mutate-action
        //
        // We need to match that.
        // (note that all other parts of the URL, like `hash`, are preserved)
        targetUrl.search = '';
    }
    const formData = new FormData(formElement);
    for (let [name, value] of formData){
        if (typeof value !== 'string') {
            // For file inputs, the native browser behavior is to use the filename as the value instead:
            //
            //   "If entry's value is a File object, then let value be entry's value's name. Otherwise, let value be entry's value."
            //   https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs
            //
            if ("TURBOPACK compile-time truthy", 1) {
                console.warn("<Form> only supports file inputs if `action` is a function. File inputs cannot be used if `action` is a string, " + "because files cannot be encoded as search params.");
            }
            value = value.name;
        }
        targetUrl.searchParams.append(name, value);
    }
    return targetUrl;
}
function checkFormActionUrl(action, source) {
    const aPropName = source === 'action' ? "an `action`" : "a `formAction`";
    let testUrl;
    try {
        testUrl = new URL(action, 'http://n');
    } catch (err) {
        console.error("<Form> received " + aPropName + ' that cannot be parsed as a URL: "' + action + '".');
        return;
    }
    // url-encoded HTML forms ignore any queryparams in the `action` url. We need to match that.
    if (testUrl.searchParams.size) {
        console.warn("<Form> received " + aPropName + ' that contains search params: "' + action + '". This is not supported, and they will be ignored. ' + 'If you need to pass in additional search params, use an `<input type="hidden" />` instead.');
    }
}
const isSupportedFormEncType = (value)=>value === 'application/x-www-form-urlencoded';
const isSupportedFormMethod = (value)=>value === 'get';
const isSupportedFormTarget = (value)=>value === '_self';
function hasUnsupportedSubmitterAttributes(submitter) {
    // A submitter can override `encType` for the form.
    const formEncType = submitter.getAttribute('formEncType');
    if (formEncType !== null && !isSupportedFormEncType(formEncType)) {
        if ("TURBOPACK compile-time truthy", 1) {
            console.error("<Form>'s `encType` was set to an unsupported value via `formEncType=\"" + formEncType + '"`. ' + "This will disable <Form>'s navigation functionality. If you need this, use a native <form> element instead.");
        }
        return true;
    }
    // A submitter can override `method` for the form.
    const formMethod = submitter.getAttribute('formMethod');
    if (formMethod !== null && !isSupportedFormMethod(formMethod)) {
        if ("TURBOPACK compile-time truthy", 1) {
            console.error("<Form>'s `method` was set to an unsupported value via `formMethod=\"" + formMethod + '"`. ' + "This will disable <Form>'s navigation functionality. If you need this, use a native <form> element instead.");
        }
        return true;
    }
    // A submitter can override `target` for the form.
    const formTarget = submitter.getAttribute('formTarget');
    if (formTarget !== null && !isSupportedFormTarget(formTarget)) {
        if ("TURBOPACK compile-time truthy", 1) {
            console.error("<Form>'s `target` was set to an unsupported value via `formTarget=\"" + formTarget + '"`. ' + "This will disable <Form>'s navigation functionality. If you need this, use a native <form> element instead.");
        }
        return true;
    }
    return false;
}
function hasReactClientActionAttributes(submitter) {
    // CSR: https://github.com/facebook/react/blob/942eb80381b96f8410eab1bef1c539bed1ab0eb1/packages/react-dom-bindings/src/client/ReactDOMComponent.js#L482-L487
    // SSR: https://github.com/facebook/react/blob/942eb80381b96f8410eab1bef1c539bed1ab0eb1/packages/react-dom-bindings/src/client/ReactDOMComponent.js#L2401
    const action = submitter.getAttribute('formAction');
    return action && /\s*javascript:/i.test(action);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=form-shared.js.map
}}),
"[project]/node_modules/next/dist/client/app-dir/form.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return Form;
    }
});
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-experimental/jsx-runtime.js [app-client] (ecmascript)");
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-experimental/index.js [app-client] (ecmascript)");
const _addbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/add-base-path.js [app-client] (ecmascript)");
const _usemergedref = __turbopack_context__.r("[project]/node_modules/next/dist/client/use-merged-ref.js [app-client] (ecmascript)");
const _approutercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [app-client] (ecmascript)");
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-client] (ecmascript)");
const _formshared = __turbopack_context__.r("[project]/node_modules/next/dist/client/form-shared.js [app-client] (ecmascript)");
const _links = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/links.js [app-client] (ecmascript)");
function Form(param) {
    let { replace, scroll, prefetch: prefetchProp, ref: externalRef, ...props } = param;
    const router = (0, _react.useContext)(_approutercontextsharedruntime.AppRouterContext);
    const actionProp = props.action;
    const isNavigatingForm = typeof actionProp === 'string';
    // Validate `action`
    if ("TURBOPACK compile-time truthy", 1) {
        if (isNavigatingForm) {
            (0, _formshared.checkFormActionUrl)(actionProp, 'action');
        }
    }
    // Validate `prefetch`
    if ("TURBOPACK compile-time truthy", 1) {
        if (!(prefetchProp === undefined || prefetchProp === false || prefetchProp === null)) {
            console.error('The `prefetch` prop of <Form> must be `false` or `null`');
        }
        if (prefetchProp !== undefined && !isNavigatingForm) {
            console.error('Passing `prefetch` to a <Form> whose `action` is a function has no effect.');
        }
    }
    const prefetch = prefetchProp === false || prefetchProp === null ? prefetchProp : null;
    // Validate `scroll` and `replace`
    if ("TURBOPACK compile-time truthy", 1) {
        if (!isNavigatingForm && (replace !== undefined || scroll !== undefined)) {
            console.error('Passing `replace` or `scroll` to a <Form> whose `action` is a function has no effect.\n' + 'See the relevant docs to learn how to control this behavior for navigations triggered from actions:\n' + '  `redirect()`       - https://nextjs.org/docs/app/api-reference/functions/redirect#parameters\n' + '  `router.replace()` - https://nextjs.org/docs/app/api-reference/functions/use-router#userouter\n');
        }
    }
    // Clean up any unsupported form props (and warn if present)
    for (const key of _formshared.DISALLOWED_FORM_PROPS){
        if (key in props) {
            if ("TURBOPACK compile-time truthy", 1) {
                console.error("<Form> does not support changing `" + key + "`. " + (isNavigatingForm ? "If you'd like to use it to perform a mutation, consider making `action` a function instead.\n" + "Learn more: https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations" : ''));
            }
            delete props[key];
        }
    }
    const isPrefetchEnabled = !!router && isNavigatingForm && prefetch === null;
    const observeFormVisibilityOnMount = (0, _react.useCallback)((element)=>{
        if (isPrefetchEnabled && router !== null) {
            (0, _links.mountLinkInstance)(element, actionProp, router, _routerreducertypes.PrefetchKind.AUTO);
        }
        return ()=>{
            (0, _links.unmountLinkInstance)(element);
        };
    }, [
        isPrefetchEnabled,
        actionProp,
        router
    ]);
    const mergedRef = (0, _usemergedref.useMergedRef)(observeFormVisibilityOnMount, externalRef != null ? externalRef : null);
    if (!isNavigatingForm) {
        return /*#__PURE__*/ (0, _jsxruntime.jsx)("form", {
            ...props,
            ref: mergedRef
        });
    }
    const actionHref = (0, _addbasepath.addBasePath)(actionProp);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)("form", {
        ...props,
        ref: mergedRef,
        action: actionHref,
        onSubmit: (event)=>onFormSubmit(event, {
                router,
                actionHref,
                replace,
                scroll,
                onSubmit: props.onSubmit
            })
    });
}
function onFormSubmit(event, param) {
    let { actionHref, onSubmit, replace, scroll, router } = param;
    if (typeof onSubmit === 'function') {
        onSubmit(event);
        // if the user called event.preventDefault(), do nothing.
        // (this matches what Link does for `onClick`)
        if (event.defaultPrevented) {
            return;
        }
    }
    if (!router) {
        // Form was somehow used outside of the router (but not in pages, the implementation is forked!).
        // We can't perform a soft navigation, so let the native submit handling do its thing.
        return;
    }
    const formElement = event.currentTarget;
    const submitter = event.nativeEvent.submitter;
    let action = actionHref;
    if (submitter) {
        if ("TURBOPACK compile-time truthy", 1) {
            // the way server actions are encoded (e.g. `formMethod="post")
            // causes some unnecessary dev-mode warnings from `hasUnsupportedSubmitterAttributes`.
            // we'd bail out anyway, but we just do it silently.
            if (hasReactServerActionAttributes(submitter)) {
                return;
            }
        }
        if ((0, _formshared.hasUnsupportedSubmitterAttributes)(submitter)) {
            return;
        }
        // client actions have `formAction="javascript:..."`. We obviously can't prefetch/navigate to that.
        if ((0, _formshared.hasReactClientActionAttributes)(submitter)) {
            return;
        }
        // If the submitter specified an alternate formAction,
        // use that URL instead -- this is what a native form would do.
        // NOTE: `submitter.formAction` is unreliable, because it will give us `location.href` if it *wasn't* set
        // NOTE: this should not have `basePath` added, because we can't add it before hydration
        const submitterFormAction = submitter.getAttribute('formAction');
        if (submitterFormAction !== null) {
            if ("TURBOPACK compile-time truthy", 1) {
                (0, _formshared.checkFormActionUrl)(submitterFormAction, 'formAction');
            }
            action = submitterFormAction;
        }
    }
    const targetUrl = (0, _formshared.createFormSubmitDestinationUrl)(action, formElement);
    // Finally, no more reasons for bailing out.
    event.preventDefault();
    const method = replace ? 'replace' : 'push';
    const targetHref = targetUrl.href;
    router[method](targetHref, {
        scroll
    });
}
function hasReactServerActionAttributes(submitter) {
    // https://github.com/facebook/react/blob/942eb80381b96f8410eab1bef1c539bed1ab0eb1/packages/react-client/src/ReactFlightReplyClient.js#L931-L934
    const name = submitter.getAttribute('name');
    return name && (name.startsWith('$ACTION_ID_') || name.startsWith('$ACTION_REF_'));
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=form.js.map
}}),
}]);

//# sourceMappingURL=node_modules_35388892._.js.map